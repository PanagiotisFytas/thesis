\chapter{Αξιολόγηση των Υλοποιηθέντων Αλγορίθμων}
\label{Chapter 4}

Σε αυτό το κεφάλαιο η επίδοση κάθε αλγορίθμου που υλοποιήθηκε αξιολογείται. Αρχικά μελετάμε την επίδοσου του 
Nidhugg-DPOR προκειμένου να δείξουμε ότι και στην υλοποίηση μας πράγματι η επίδοσήτ του διαφέρει από αυτή του Source-DPOR. Η
αξιολόγηση χωρίζεται σε δύο μέρη. Στο πρώοτ μέρος χρησιμοποιούνται μικϱά συνθετικά προγράμματα ενώ στο δεύτερο χρησιμοποιείται
πραγματικό λογισμικό. Τα συνθετικά τεστ μπορούν να βρεθούν στο παράρτημα. 

\section{Synthetic Tests}
Τα συνθετικά τεστ έχουν προέλθει από διάφρορες πηγές και δεν είναι ιδιαίτερε πολύπλοκα καθώς θέλουμε απλώς να μας δείξουν τις
διαφορές στην επίδοση μεταξύ Source-DPOR και Nidhugg-DPOR.

\begin{itemize}
\item writer-N-readers: Σε αυτό το τεστ N threads διαβάζουν (readers) την ίδια global μεταβλητή και ένα thread (writer)
γράφει σε αυτή τη μεταβλητή. Είναι σηματνικό να σημειώσουμε ότι πριν την ανάγνωση της μεταβλητής κάποιο local operation του thread λαμβάνει
χώρα. Επομένως αναμένουμε σημαντική διαφορά στην επίδοση μεταξύ των source sets και persistent sets.

\item Account: Αυτό το τεστ αποτελεί μια προσομοίωση ενός τραπεζικού λογαρισαμού και χρησιμοποιεί locks για κάθε operation που συμβαίνει
    στον λογαριασμό. Υπάρχουν τρείς δυνατές λειτουργίες: Να αυξήσουμε το απόθεμα του λογαριασμού κατά ένα ποσό. Να κάνουμε ανάληψη μειώνοντας
    το απόθεμα με ένα συγκεριμένο ποσό. Να ελέγξουμε το αποτέλεσμα check\_result (έλεγχος αποτελέσματος) όπου επιβεβαιώνουμε ότι $\text{final\_balance} ==
\text{initial\_balance} + \text{deposit} - \text{withdraw}$ και μπορεί να συμβεί μόνο αν η κατάθεση και η ανάληψη έχουν ολοκληρωθεί.

\item Micro: Σε αυτό το τεστ τρία threads δημιουργούνται και εκτελούν δύο φορές την εντολή \verb|x++| δύο φορές. Η συγκεκριμένη εντολή \verb|x++|
αποτελείται από δύο επιμέρους λειτουργίες μία ανάγωσης της τιμής της μεταβλητής και μία το γράψιμο της μεταβλήτης.

\item Last-zero test: Το πρόγραμμα αποτελείται από N+1 threads τα οποία εκτελούν λειτουργίες σε N+1 στοιχεία ενός πίνακα που αρχικά όλα είναι μηδενικά.
Σε αυτό το πρόγραμμα το thread 0 αναζητά το μηδενικό στοιχείο του πίνακα με το μεγαλύτερο index ενώ τα άλλα N threads
διαβάζουνε από τον πίνακα ένα στοιχείο και ενημερώνουν την τιμή του επόμενου. Η τελική κατάσταση του προγράμματος ορίζεται μοναδικά από τις που θα 
έχει ο πίνακα. Το Last-zero δεν παράγει περισσότερα tracce από τον DPOR για λόγους που εξηγούνται στη συνέχεια. Μια παραλλαγή του ενδιάμεσου
κώδικα μπορεί να δείξει τη διαφορά.

\item Indexer.c: Αυτό το benchmark χρησιμοποιεί την compare-and-swap(CAS) primitive instruction για να ελέγξει να ένα entry στον
    πίνακα είναι 0 και στη συνέχεια θέτει μια καινούρια τιμή σε αυτό.

\item Indexermod.c: Σε αυτό το benchmark όλα τα threads διασχίζουν και προσπαθούν να γράψουν έναν πίνακα με αποτέλεσμα να προκύπτουν
    πολλές συγκρούσεις μεταξύ των threads.

\end{itemize}

\section{RCU}

To Read-Copy-Update (RCU) είναι ένα μηχανισμός συγχρονισμού που εφευρέθηκε από τους McKenney and Slingwine \cite{McKenney98},
και βασίζεται στην αμοιβαία απόκληση πόρων. Προστέθηκε τον πυρήνα του Linux τον Οκτώβριο του 2002 και επέτρεψε σημαντίκη 
βελτίωση στην ταυτόχρονη ανάγνωση και ενημέρωση. Σε αντίθεση με τα συνήθη locking primitives που διασφαλίζουν αμοιβαίο αποκλεισμό
μεταξύ threads ανεξάρτητα με το αν είναι αναγνώστες ή εγγραφείς ή με τη χρήση reader-writer locks που επιτρέπουν ταυτόχρονες
αναγνώσεις ή μία εγγραφή, το RCU επιτρέπει ταυτόχρονες αναγνώσεις και μία εγγραφή.

Η τεχνική του DPOR χρησιμοποιήθηκε σαν μια προσέγγιση για ελεγχθεί συστηματικά ο κώδικα του RCU που χρησιμποιείται στο Linux kernel (Tree
RCU) κάτω από το memory model του sequential consistency. Η μοντελοποίηση επιτρέπει στο Nidhugg
να αναπαράγει σε μερικά δευτερόλεπτα σφάλαμτα που έχουν αναφερθεί κατα καιρούς σχετικά με το RCU \cite{Spin}.

Το RCU είναι ένα ιδανικό testcase για την αξιολόγησης διαφόρων υλοποιήσεων του DPOR και Bounded DPOR καθώς:
\begin{itemize}
\item Είναι ένα πρόγραμμα που χρησιμοποιείται πραγματικά και όχι ένα συνθετικό τεστ synthetic test.
\item Ο αριθμός των διαφορετικών δρομολογήσεων είναι αρκετά μεγάλος για να δούμε διαφορές στην επίδοση.
\item Προηγούμενη δουλειά  \cite{Spin} μας επιτρέπει να αξιολογήσουμε την ορθότητα των υλοποιήσεων μας.
\end{itemize}


\section{Αξιολόγηση των Μη Φραγμένων Αλγορίθμων}
Όπως έγινε σαφές στο κεφάλαιο \ref{unbounded} η υλοποίηση των persistent sets είναι πολύ σημαντική καθώς χρησιμοποιείται
σε κάθε bounding technique. Σε αυτή την ενότητα θα δείξουμε τις διαφοϱες στην επίδοση μεταξύ των Source-DPOR και
Nidhugg-DPOR τόσο στα συνθετικά tests όσο και στο RCU.

\subsection{Αξιολόγηση των Persistent Sets στα Συνθετικά Τεστ}
Τα αποτελέσματα παρουσιάζονται με δύο διαφορετικούς τρόπους. Τα αποτελέσματα για το writer-N-readers testcase δίνονται σε μορφή γραφήματος, 
στο Figure \ref{writer-N-readers}, προκειμένου να απεικονίσουμε την κλιμάκωση του χώρου καταστάσεων καθώς
και την σημαντική επίδραση που έχει ο source-DPOR. Τα υπόλοιπα αποτελέσματα δίνονται στο Table \ref{Source-DPOR vs Nidhugg-DPOR for synthetic tests} 
ώστε να μπορέσουμε εύκολα να τα συγκρίνουμε. Ηθελημένα δεν σημειώνουμε τη διάρκεια εκτέλεση καθώς στις περισσότερες περιπτώσεις ο αριθμός
των traces είναι πολύ μικρός όπως και ο χρόνος.
Όπως ήταν αναμενόνμενο τα συνθετικά testcase έδειξαν ότι ο Source-DPOR πράγματι έχει καλύτερη επίδοση από τον
Nidhugg-DPOR. Όπως ήταν αναμενόμενο ο Source-DPOR εξερευνά λιγότερα traces από τον Nidhugg-DPOR. Είναι σημαντικό να
σημειώσουμ ότι η διαφορά οφείλεται στον αριθμός των sleep set blocked traces τα οποία προκύτπουν από τον DPOR αλγόριθμο 
και τα οποία δεν συναντάμε στον source DPOR. Αυτή η μείωση δεν είναι σταθερή σε όλες τις περιπτώσεις.

\graph{img/wNr.png}{writer-N-readers}

\smalltabular{"tables/synthetic_unbounded.tex"}{Source-DPOR vs Nidhugg-DPOR for synthetic tests}

\subsection{Evaluation of Persistent sets on RCU}
Παρατηρήσμα ότι δεν υπάρχει διαφορά μεταξύ Source sets και persistent sets και επομένως δεν παρουσιάζουμε αποτέλεσματα
καθώς αυτά θα συμφωνούν με αυτα του \cite{Spin}. Ο λόγος που τα αποτελέσατα του Nidhugg-DPOR και Source-DPOR είναι ίδια οφείτεαι 
στις λειτουργίες που εκτελούνται και που δεν επιτρέπουν την βελτιστοποίηση του Source-DPOR.

\section{Σύγκριση με τα αποτελέσματα του Concuerror}
Ο Concuerror είναι ένα εργαλείο που αναπτύχθηκε από την ίδια ερευνητική ομάδα και έχει στόχο να εντοπίζει σφάλματα
σε προγράμματα Erlang. Επομένως η σύγκριση της επίδοσής του μπορεί να μας δώσει μια ένδειξη για την ορθότητα των
υλοποιήσεών μας.
Υπάρχουν περιπτώσεις here Concuerror's Source-DPOR εξερευνά λιγότερα traces από τον Classic-DPOR ενώ στο Nidhugg αυτό δεν ισχύει.
Επιπλέον, η υλοποίηση του Nidhugg-DPOR φαίνεται να εξερευνά λιγότερα traces από αυτά που εξερευνόνται από τον
Classic-DPOR του Concuerror \cite{AbdullaAronisJohnssonSagonasDPOR2014}. Προσπαθήσαμε να ερμηνεύσουμε αυτή τη συμπεριφορά και συμπεράναμε
ότι οι λόγοι που οι τιμές διαφέρουν είναι οι εξής:

\begin{itemize}
  \item Η υλοποίηση των persistent set: Στον Concuerror ο υπολογισμός των persistent sets είναι πιο χαλαρός από του
  Nidhugg με αποτέλεσμα το τελευταίο να υπολογίζει μικρότερα persistent sets. Στο Figure \ref{Lastzero Concuerror} 
  δίνεται το παράδειγμα του Last-zero testcase του Concuerror ως παράδειγμα υπολογισμού μεγαλύτερου persistent set. Στην πραγματικότητα
  το $q$ δε θα έπρεπε ποτέ να προστεθεί στο persistent set καθώς δεν έχει conflict με άλλες διεργασίες.

  \item Ο αριθμός των traces που εξερευνότναι σχετίζεται άμεσα με την δρομολόγηση των γεγονότων: Έστω ένα πρόγραμμα που αποτελείται από
      δύο διεργασίες που διαβάζουν μια μεταβλητή $x$ και μία που γράφει σε αυτή τη μεταβλητή $x$. Στο Figure \ref{Scheduling Effect
  reader-writer-reader} παρουσιάζεται η εξερεύνηση όταν ο ένας αναγνώστης δρομολογείται πρώτος. Παρατηρούμε ότι εξερευνόνται ακριβώς
  4 traces. Στην περίπτωση που δρομολογούντας πρώτα ο εγγραφέας \ref{Scheduling Effect
  writer-reader-reader} θα εξερευνότναν 5 traces με το ένα trace να γίνεται sleep set blocked.

\end{itemize}

\tracelong{lastzero.pdf}{Lastzero Concuerror}

\trace{schedulingrwr.pdf}{Scheduling Effect reader-writer-reader}
\trace{schedulingwrr.pdf}{Scheduling Effect writer-reader-reader}


\section{Αξιολόγηση Τεχνικών Περιορισμού}
Κατά την αξιολόγηση των τεχνικών περιορισμού λάβαμε υπόψιν δύο παράγοντες. Τον αριθμό των traces που εξερευνόνται και το κατα πόσο 
καλύπτουμε όλο το state space. Η πρώτη μετρική σχετίζεται με τον χρόνο που απαιτείται για να βρεθεί ένα σφάλμα. Η δεύτερη είναι 
σημαντική καθώς αντικατοπτρίζει το tradeoff μεταξύ του χρόνου και της ακρίβειας των αποτελεσμάτων με την έννοια του ότι η μη εύρεση ενός
σφάλματος δε θα συνεπάγεται την ύπαρξή του αν δεν καλύπτουμε ολόκληρο το χώρο καταστάσεων.
Η σημασία του soundness έχει συζητηθεί στο Κεφάλαιο \ref{bounded}. Όπως είναι αναμενόμενο ταχύτεροι αλγόριθμοι περιορίζουν το soundness της αναζήτησης.

\subsection{Αξιολόγηση Τεχνικών Περιορισμού στα Συνθετικά Τεστ}

Τα αποτελέσματα στα διάφορα testcases παρουσιάζονται σε ενότητα. Όπως και στις προηγούμενες ενότητες παρουσιάζονται και πάλι με δύο διαφορετικούς
τρόπους.

\graph{img/wNrB.png}{writer-N-readers bounded}
\smalltabular{"tables/bounded.tex"}{Traces for various bound limits}

Όπως ήταν αναμενόμενο ο Naive-BPOR εξερευνά σημαντικά λιγότερα traces από τον Nidhugg-BPOR και τον Source-DPOR. Όμως, όπως ήδη έχει αναφερθεί 
δεν εξερευνάται όλο το state spacce. Ο αριθμός των tracecs που εξερευνόνται στις sound εκδοχές των αλγορίθμων είναι σημαντικά μεγαλύτερος καθώς
η προσθήκη των συντηρητικών διακλαδώσεων αυξάνει πολύ το state space.
Ένα μη αναμενόμενο αποτέλεεσμα είναι ότι δεν υπάρχει διαφορά μεταξύ του Nidhugg-BPOR και του Source-BPOR.

\subsection{Αξιολόγηση των Τεχνικών Περιορισμού στο RCU}
Τα αποτελέσματα των διαφόρωων υλοποιήσεων του BPOR δίνονται εδώ. Ας σημειώσουμε ότι δεδομένου ότι ο Source-DPOR δεν παρουσιάζει καλύτερη επίδοση
από τον Nidhugg-DPOR δεν μπορούμε να αναμένουμε διαφορά στην επίδοση και μεταξύ των φραγμένων εκδοχών τους. Πράγματα οι δοκιμές που έγιναν
δεν παρουσίασαν καμία διαφοράρ και γι αυτή το λόγο μόνο η μία εκδοχή παρουσιάζεται στα αποτελέσματα. Κάθε πίνακα παρουσιάζει τα αποτελέσματα 
για ένα συγκεκριμένο bound σε ό,τι αφορά τον αριθμό των traces, το χρόνο που διήρκησε η εξερεύνηση όσο και στο κατα πόσο εντοπίστηκε σφάλμα.
Συμβολίζουμε με F τον εντοπισμό του σφάλματος και με NF τον μη εντοπισμό.

\bigtabular{"tables/nobound.tex"}{RCU results without bound}
\bigtabular{"tables/naivevsbpor0.tex"}{RCU results for bound $b=0$}
\bigtabular{"tables/naivevsbpor1.tex"}{RCU results for bound $b=1$}
\bigtabular{"tables/naivevsbpor2.tex"}{RCU results for bound $b=2$}
\bigtabular{"tables/naivevsbpor3.tex"}{RCU results for bound $b=3$}
\bigtabular{"tables/naivevsbpor4.tex"}{RCU results for bound $b=4$}
\bigtabular{"tables/dporvsbpor.tex"}{Comparison between DPOR and BPOR}


Παρατηρούμε ότι τελικά τα σφάλματα εντοπίζονται πολύ γρηγορότερα. Το πιο σημαντικό αποτέλεσμα είναι το
\verb|-DFORCE_FAILURE_3| το οποίο εντοπίζεται σε 6 seconds για bound $b=3$ ενώ απαιτούνται 464.77 δευτερόλεπα στην αντίστοιχη unbounded εκδοχή.
Επιπλέον παρατηρούμε ότι με $b=4$ όλα τα σφάλματα εντοπίζονται. Έτσι φαίνεται να επιβεβαιώνεται η εμπειρική 
παρατήρηση ότι τα λάθη εντοπίζονται σε μικρό bound. Το γεγονός ότι αυτά τα λάθη είναι κατασκευασμένα δεν μπορούν 
να αποτελέσουν ισχυρή ένδειξη, δεν παύουν όμως να είναι ένα στοιχείο.
Όπως ήταν αναμενόμενο για μεγαλύτερα bounds ($b=4$) o αριθμός των traces αυξάνει εκθετικά.
Ένα άλλο πολύ ενδιαφέρον αποτέλεσμα είναι ότι όσο το bound μεγαλώνει το σφάλμα παίρνει περισσότερη ώρα να βρεθεί. Στο παράδειγμα
\verb|-DFORCE_FAILURE_3| παρατηρούμε ότι το σφάλμα δεν εντοπίζεται για $b=4$ στο δοθέν χρονικό διάστημα ενώ εντοπίζεται πολύ γρήγορα 
για bound $b=2$.

\subsection{A known bug}
Η αλλαγή στη δρομολόγηση των threads αποκάλυψε και ένα σφάλμα στην υλοποίηση του Nidhugg. Συγκεκριμένα αυτή η αλλαγή οδηγεί
σε αύξηση στον αριθμό των traces. Προκειμένου να παρούσιασουμε καλή σύγκριση των αποτελεσμάτων διαδόσαμε το σφάλμα και στην unbounded εκδοχή 
του αλγορίθμου.
Τα αποτελέσματα είναι και πάλι εντυπωσιακά  \ref{Comparison between DPOR and BPOR with the bug}. 

\bigtabular{"tables/dporvsbporpriority.tex"}{Comparison between DPOR and BPOR with the bug}

\section{Ισοδυναμία μεταξύ Classic-BPOR και Source-BPOR (Ορθότητα του Source-BPOR)}
Προς έκπληξη μας τα αποτελέσματα του Classic-BPOR και Source-BPOR πάντα ταυτίζονται. Περαιτέρω διερεύνηση έδειξε ότι αυτές οι 
τεχνικές είναι ισοδύναμες.

Μια διαισθητική εξήγηση της ισοδυναμίας των δύο τεχνικών βασίζεται στην εξής παρατήση:
\begin{itemize}
  \item Έστω $B_v$ μια συνάρτηση που υπολογίζει το bound count τότε $B_v(pre(E,e)) \leq B_v(E)$ για κάθε $e \in E$.
  \item Τα σημεία που αυξάνεται το preemption count είναι τα σημεία των διακλαδώσεων.
\end{itemize}

Επομένως ο Classic-BPOR αλγόριθμος θα προσθέσει και συντηρητικές διακλαδώσεις στα σημεία που το preemption count αυξάνεται.
Μη συντηρητικές διακλαδώσεςι που θα προστίθεντο απορρίπτονται από τον Source-DPOR προστίθενται ως συντηρητικές καθώς οδηγούν σε
εξερεύνηση ήδη εξερευνηθέντων traces με μικρότερο preemption count.

Έτσι δείξαμε την ισοδυναμία του Source-BPOR με τον Classic-BPOR.
