\chapter{Εισαγωγή}

Ο νόμος του Moore, που πήρε το όνομά τους από τον συνιδρυτή της Intel, Gordon Moore, αναφέρει ότι ο αριθμός των τρανζίστορ που
μπορούν να τοποθετηθούν σε ένα ολοκληρωμένο κύκλωμα διπλασιάζεται περίπου κάθε δυο χρόνιοα. Για δεκαετίες οι κατασκευαστές 
πετύχαιναν την συρρίκνωση των διαστάσεων των chip, επιτρέποντας στο νόμο του Moore να συνεχίζει να επαληθεύεται ενώ οι 
τελικοί καταναλωτές συνέχιζαν να απολαμβάνουν ακόμα πιο ισχυρούς φορητούς υπολογιστές, tablets και έξυπνα τηλέφωνα. Από την
άλλη οι μηχανικοί λογισμικού μπορούσαν απλώς να περιμένουν το νόμο του Moore να συνεχίζει να ισχύει ώστε να μπορούν να κατασκευάσουν
ακόμα πιο απαιτητικά προγράμματα. Παρολ' αυτά περιορισμοί όπως η αύξηση της θερμοκρασία και η συχνότητα των ρολογιών εμποδίζουν
την περεταίρω βελτίωση στην επίδοση του λογισμικού. Προκειμένου οι προγραμματιστές να ικανοποιήσουν την απαίτηση για αποδοτικό
λογισμικό, πρότυπα προγραμματισμού όπως αυτό του ταυτοχρονισμού έχουν γίνει αναγκαία. Η χρήση αυτού του προτύπου όμως δημιουργεί νέες 
προκλήσεις καθώς ο προγραμματισμός γίνεται πιο δύσκολος και πιο επιρρεπής σε λάθη από το ακολουθιακό πρότυπο.
 
Συγκεκριμένα, συχνά προβλήμα που εμφανίζονται στο μοντέλο του ταυτοχρονισμού είναι:
\begin{description}
\item[Race conditions] Όπου μία δρομολόγηση έχει μη αναμενόμενο αποτέλεσμα. 
\item[Deadlocks] Δύο οι περισσότερες διεργασίες σταματούν και περιμένουν η μία την άλλη.
\item[Livelocks] Δύο οι περισσότερες διεργασίες συνεχίζουν να εκτελούνται χωρίς να σημειώνουν πρόοδο.
\item[Resource starvations] Δύο οι περισσότερες διεργασίες σταματούν να εκετελούνται περιμένοντας για πόρους.
\end{description}
Το χειρότερο όμως είναι ότι αυτάτ τα προβλήματα χαρακτηρίζονται συνήθως ως Heisenbugs~\cite{Musu08}; 
Δηλαδή, μπορεί να αλλάξουν συμπεριφορά ή να εξαφανιστούν τελείως όταν κάποιος προσπαθήσει να τα απομονώσει καθώς 
σχετίζονται άμεσα με τη σειρά που οι διεργασίες εκτελούνται.

\section{Δοκιμή,Έλεγχος και Επαλήθευση Ταυτόχρονων Προγραμμάτων}

Η δοκιμή και η επαλήθευση ταυτόχρονων προγραμμάτων είναι μια απαιτητική διαδικασία. Μια τεχνική που χρησιμοποιείται για
την εξερεύνηση του χώρου καταστάσεων είναι ο έλεγχος του μοντέλου (model checking)~\cite{WikipediaModelChecking}. To
model checking είναι μια μέθοδος για την τυπική επιβεβαίωση ταυτόχρονων προγραμμάτων και συστημάτων μέσω απαιτήσεων για
το σύστημα εκφρασμένων σε λογική φόρμουλα και την χρήση αποδοτικών αλγορίθμων που μπορούν να ελέγξουν το ορισθέν μοντέλο
όπως έχει οριστεί από το σύστημα ώστε να ελεγχθεί αν οι απαιτήσεις εξακολουθούν να ισχύουν. Το μεγάλο πρόβλημα με τα
εργαλία που κάνουν model checking είναι ότι πρέπει να αντιμετωπίσουν την εκθετική αύξηση του χώρου καταστάσεων καθώς
ένας μεγάλος αριθμός καταστάσεων πρέπει να αποθηκευτεί. Πολλές τεχνικές έχουν προταθεί προκειμένου να αντιμετωπιστεί
αυτό το πρόβλημα. To Stateless Model Checking, για παράδειγμα, αποφεύγει την αποθήκευση καθολικών καταστάσεων. Αυτή η
τεχνική για παράδειγμα έχει υλοποιηθεί σε εργαλεία όπως το Verisoft~\cite{SMC,Gode05}, CHESS~\cite{Musu08},
Concuerror~\cite{Chri13}, Nidhugg~\cite{AbdullaAronisAtigJonssonLeonardssonSagonasSMC2015} και RCMC~\cite{RCMC}. Η
παρατήρηση ότι δύο δρομολογήσεις είναι ισοδύναμες αν η μία μπορεί μπορεί να προκύψει από την άλλη με την εναλλαγή
εκτέλεσης ανεξάρτητων βημάτων είναι ο πυρήνας της ιδέας της αναγωγής σε δυναμικές σχέσεις μερικής διάταξης (Partial
Order Reduction)~\cite{Valmari1991, Peled1993, Godefroid1996,POR,JACM} και χρησιμοποιείται σε διάφορα εργαλεία. Το
Dynamic Partial Order Reduction (DPOR) εντοπίζει εξαρτήσεις μεταξύ ενεργειών διαφορετικών νημάτων ενώ το πρόγραμμα
εκτελείται~\cite{FlanaganDPOR,JACM}. Η εξερεύνηση ξεκινάει με μια αυθαίρετη δρομολόγηση της οποίας τα βήματα στη συνέχεια χρησιμποιούνται
για την αναγνώρηση λειτουργιών όπου εναλλακτικές δρομολογήσεις πρέπει να εξερευνηθούν προκειμένου να συλληφθεί η συνολική συμπεριφορά του προγράμματος.
Μία άλλη προσέγγιση είναι το οριοθετημένο (bounded) model checking \cite{BoundedModelChecking} όπου ένας πεπερασμένος αριθμός από βήματα ξεδιπλώνεται και
και οι απαιτήσεις ελέγχονται γι αυτό τον αριθμό βημάτων. Το bounded model checking μπορεί να συνδιαστεί με το partial order reduction για να μοντελοποιήσει
εκετλέσεις και έχει υλοποιηθεί αποδοτικά σε εργαλία όπως τα CBMC~\cite{CBMC}, Nidhugg~\cite{AbdullaAronisJohnssonSagonasDPOR2014} and RCMC~\cite{RCMC}. 
Δυστυχώς, όλες αυτές οι τεχνικές εξακολουθούν να πάσχουν σε κάποιο βαθμός από το πρόβλημα της έκρηξης του state space.
Προκειμένου να αντιμετωπιστείς αυτό το πρόβλημα επιπλέον οριοθέτηση απαιτείται. Πόλλες και διαφορετικές τεχνικές έχουν εξεταστεί \cite{Thomson}, όπως το 
preemption bounding, delay bounding, ένας ελεγχόμενος τυχαίος δρομολογιτής και η πιθανοτική δοκιμή του ταυτοχρονισμού (probabilistic concurrency testing, PCT).

\section{Aim of this Thesis}

Στόχος της παρούσας διπλωματικής είναι:
\begin{itemize}
\item Η υλοποίηση preemption bounding τεχνικών για τον DPOR~\cite{BPOR} στο εργαλείο Nidhugg.
\item Να εξεταστεί κατα πόσο τεχνικές όπως το Source-DPOR και Optimal-DPOR~\cite{AbdullaAronisJohnssonSagonasDPOR2014}
  μπορούν να ενισχύσουν την υλοποίηση του bounded partial order reduction, κατα προτίμηση με την παροχή κάποιου είδους εγγυήσεων.
\item Η επιβεβαίωση ή όχι της δυνατότητας του bounded dynamic partial order reduction να εντοπίζει λάθη γρηγορότερα από το unbounded partial order reduction.
\item Να ελεγχθεί κατα πόσο η εμπειρική παρατήρηση ότι τα λάθη μπορούν να εμφανιστούν σε μικρό αριθμό απο preemptions~\cite{Musu07} είναι σωστή.
\item Η εξερεύνηση εναλλακτικών προσεγγίσεων στο προβλήμα του preemption-bounded partial order reduction.
\end{itemize}

\iffalse
The purpose of this thesis is the implementation of a preemption bounding technique \cite{BPOR} for Nidhugg and the combination
of this technique with the a novel technique \cite{AbdullaAronisJohnssonSagonasDPOR2014} suggested for better coverage of the state space.
The bounded-DPOR was used to verify the linux kernel \cite{LinuxKernel} and specifically RCU \cite{Spin}. RCU is a synchronization
mechanism used heavily in Linux kernel, and many of the kernel’s subsystems rely on RCU’s correct operation. By using BPOR the minimum preemptive
switches required to track failure injections were counted. As a result the empirical observation that errors occur in a small bound count was confirmed.
Moreover, the possible application of various optimizations used for unbounded DPOR on bounded DPOR are examined. 
\fi

\section{Overview}
Στο Κεφάλαιο \ref{sec:background} παρουσιάζουμε το θεωρητικό υπόβαθρο τόσο του unbounded όσο και του bounded DPOR.
Στο Κεφάλαιο \ref{unbounded} και \ref{bounded} παρουσιάζονται οι αλγόριθμοι για unbounded DPOR και bounded DPOR.
Στο Κεφάλαιο~\ref{implementations} συζητόνται οι τεχνικές λεπτομέριες των υλοποιήσεων.
Η αξιολόγηση κάθε αλγορίθου δίνεται στο Κεφάλαιο \ref{Chapter 4} όπου οι
αλγόριθμοι δοκιμάζονται τόσο με τη χρήση συνθετικών τεστ όσο και με τη χρήση
κώδικα σημαντικού μεγέθους (RCU) που είναι μέρος του πυρήνα του Linux.
Στο Κεφάλαιο \ref{Chapter 5} παρουσιάζεται μια εναλλακτική προσέγγιση στο bounding problem.
Τελος στο Κεφάλαιο \ref{Chapter 6} συνοψίζουμε τα προηγούμενα κεφάλαια και καταλήγουμε σε κάποια συμπεράσματα ενώ παρουσιάζουμε και κάποιες πιθανές προεκτάσεις για την παρούσα δουλειά.
