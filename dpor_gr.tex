\chapter{Δυναμικές Τεχνικές Μερικής Διάταξης}
\label{dpor}

\section{Βασικές έννοιες του DPOR}

Γενικά, οι αλγόριθμοι DPOR χρησιμοποιούν μια αναζήτηση βάθρου βάθους για πρώτη φορά για να εξερευνήσουν τον χώρο κατάστασης ενός ταυτόχρονου συστήματος.
Αυτή η εξερεύνηση βασίζεται σε δύο βασικές έννοιες: \textit{persistent sets} και \textit{sleep sets}, οι οποίες βεβαιώνουν
επαρκές τμήμα (τουλάχιστον μία παρεμβολή από διαφορετικά ίχνη Mazurkiewicz) του κρατικού χώρου,
ενώ προσπαθεί να ελαχιστοποιήσει οποιαδήποτε περιττή εξερεύνηση.

Διαισθητικά, ένα επίμονο σύνολο σε κατάσταση $s$ είναι (συγκεκριμένο) υποσύνολο του $enabled(s)$ του οποίου η εξερεύνηση εγγυάται ότι όλα
θα διερευνηθούν μη ισοδύναμες παρεμβολές (από διαφορετικά ίχνη Mazurkiewicz). Αυτό είναι ζωτικής σημασίας για την απόδειξη της ορθότητας του Classic
Αλγόριθμοι DPOR \cite{FlanaganDPOR}, με την παραδοχή
(που λαμβάνεται υπόψη από την αφαίρεσή μας) ότι ο κρατικός μας χώρος είναι ακυκλικός και πεπερασμένος.
Ο τρόπος κατασκευής τέτοιων συνόλων διαφέρει από το χαρτί στο χαρτί \cite{FlanaganDPOR, Lei:2006:RTC:1248722.1248743, 10.1007/3-540-53863-1_36},
και αυτές οι μεταβολές μπορούν να οδηγήσουν σε διαφορετικούς βαθμούς μείωσης του κρατικού χώρου.

Η τεχνική του ύπνου, η οποία είναι δωρεάν για τα επίμονα σύνολα (δεν συμβάλλει στην αξιοπιστία του αλγορίθμου),
στοχεύει στην περαιτέρω μείωση του αριθμού των διερευνηθέντων διεμπλοκών.
Ο ύπνος που έχει οριστεί σε μια αλληλουχία εκτέλεσης $E$ περιέχει διαδικασίες, των οποίων η εξερεύνηση θα ήταν περιττή,
εμποδίζοντας την διερεύνηση ισοδύναμων παρεμβολών.

Συγκεκριμένα, μετά την διερεύνηση του $E.p$, η διαδικασία $p$ προστίθεται στο set sleep
στο $E$. Από αυτό το σημείο, το $p$ θα υπάρχει σε οποιοδήποτε σετ ύπνου μιας ακολουθίας εκτέλεσης
της μορφής $E.w$, με την προϋπόθεση ότι το $E.w$ είναι επίσης μια ακολουθία εκτέλεσης και $E\models p \diamondsuit w$.
Οι διαδικασίες στο σετ ύπνου δεν πρόκειται να εκτελεστούν από αυτό το σημείο, εκτός αν εντοπιστεί εξάρτηση.
Για παράδειγμα, το $p$ θα αφαιρεθεί από τον ύπνο που έχει οριστεί στο $E.w.q$ αν εντοπιστεί εξάρτηση μεταξύ του
τα επόμενα βήματα των $q$ και $p$.

Μπορούμε να αποδείξουμε \cite{Godefroid1996} ότι τα σύνολα ύπνου θα αποκλείσουν τελικά όλες τις πλεονάζουσες παρεμβολές και έτσι
οι μόνες παρεμβολές που πρόκειται να εξερευνηθούν πλήρως θα ανήκουν σε διαφορετικά ίχνη Mazurkiewicz.
Ωστόσο, αυτό δεν σημαίνει ότι τα σετ ύπνου αποφεύγουν όλες τις περιττές εξερευνήσεις. Για να επεξεργαστείτε, ύπνο σύνολα
καθιστούν δυνατή την εξερεύνηση μιας αλληλεπίδρασης, η οποία ανήκει στο ίδιο ίχνος Mazurkiewicz ως ένα άλλο
διεμπλοκή που έχει ήδη εξερευνηθεί, για να μπλοκάρει τελικά, έχοντας όλες τις ενεργοποιημένες διαδικασίες της
εμφανίζονται στο σετ ύπνου. Αυτό ονομάζεται \textit{sleep-set blocking} και σημαίνει ότι όλα τα πιθανά ίχνη, από το σημείο αυτό,
είναι περιττές και επομένως δεν χρειάζεται να διερευνηθούν περαιτέρω. Τα σετ ύπνου δεν εγγυώνται τη βέλτιστη λειτουργία
για έναν αλγόριθμο DPOR, δεδομένου ότι περιττώνονται ίχνη διερευνηθούν, αν και όχι εντελώς.

Η πηγή-DPOR \cite{AbdullaAronisJohnssonSagonasDPOR2014} αντικαθιστά τα επίμονα σύνολα με \textit{source sets} προκειμένου να επιτευχθεί
σημαντικά καλύτερη μείωση της ποσότητας των διερευνηθέντων διεμπλοκών. Ωστόσο, η πηγή-DPOR εξακολουθεί να πάσχει από ύπνο
μπλοκάρισμα. Optimal-DPOR \cite{AbdullaAronisJohnssonSagonasDPOR2014}
συνδυάζει την έννοια των συνόλων πηγών με το \textit{wakeup trees} για να αποφύγει πλήρως την παρεμπόδιση της δέσμης ύπνου και να οδηγήσει στην εξερεύνηση
του βέλτιστου υποσυνόλου των παρεμβολών.

\section{Ορισμός Source Sets}

Προτού καθορίσουμε τυπικά τα πηγαία σύνολα, πρέπει να καθορίσουμε τις έννοιες
των πιθανών αρχικών βημάτων σε μια αλληλουχία εκτέλεσης \cite{AbdullaAronisJohnssonSagonasDPOR2014}:

\begin{definition}{(Initials after an execution sequence $E.w$, $I_{[E]}(w)$)}\\
Για μια ακολουθία εκτέλεσης $E.w$, αφήστε $I_{[E]}(w)$ να υποδηλώσει το σύνολο του
διαδικασίες που εκτελούν συμβάντα $e$ στο $dom_{[E]}(w)$ που δεν έχουν
"Συμβαίνει-πριν" προκατόχους στο $dom_{[E]}(w)$. Πιο τυπικά,
$p \in I_{[E]}(w)$ αν $p \in w$ και δεν υπάρχει άλλο συμβάν $e \in dom_{[E]}(w)$ με
$e \rightarrow_{E.w} next_{[E]}(p)$.
\end{definition}

Με τη χαλάρωση αυτού του ορισμού, μπορούμε να πάρουμε τον ορισμό του Weak Initials, $WI$:

\begin{definition}{(Weak Initials after an execution sequence $E.w$, $WI_{[E]}(w)$)}\\
Για μια ακολουθία εκτέλεσης $E.w$, αφήστε $WI_{[E]}(w)$ να δηλώσει την ένωση $I_{[E]}(w)$ και το σύνολο
διαδικασίες που εκτελούν συμβάντα $p$ έτσι ώστε $p \in enabled(s_{[E]}) $.
\end{definition}

Για να διευκρινιστούν αυτές οι σημειώσεις, για μια ακολουθία εκτέλεσης $E.w$:
\begin{itemize}
    \item  $p \in I_{[E]}(w)$ iff there is a sequence $w'$ such that $E.w \simeq E.p.w'$, and
    \item  $p \in WI_{[E]}(w)$ iff there are sequences $w'$ and $v$ such that $E.w.v \simeq E.p.w'$.
\end{itemize}

\begin{definition}{(Source Sets)}\label{def:Source Sets}\\
Αφήστε το $E$ να είναι μια ακολουθία εκτέλεσης,
και αφήστε το $W$ να είναι ένα σύνολο ακολουθιών, έτσι ώστε το $E.w$ να είναι μια εκτέλεση
ακολουθία για κάθε $w \in W$. Ένα σύνολο $T$ των διαδικασιών είναι μια πηγή που έχει οριστεί για
$W$ μετά από $E$ εάν για κάθε $w \in W$ έχουμε $WI_{[E]}(w) \cap P  = \emptyset$.
\end{definition}

Μια άμεση συνέπεια αυτού του ορισμού είναι ότι κάθε
σύνολο διαδικασιών που μπορούν να καλύψουν τον πλήρη χώρο κατάστασης μετά από μια ακολουθία εκτέλεσης $E$
μπορεί να θεωρηθεί ένα σύνολο πηγών $E$.

\section{Source-DPOR Αλγόριθμος}
Εδώ παρουσιάζουμε τον αλγόριθμο source-DPOR \cite{AbdullaAronisJohnssonSagonasDPOR2014}.

\SetKwProg{Fn}{Function}{}{}
\SetKwHangingKw{Let}{let}
\begin{algorithm}
    \caption{Πηγή-DPOR}
    \label{Source}
    \Fn{Explore($E$,$Sleep$)}{
        \If{$\exists p \in (enabled(s_{[E]}) \backslash Sleep)$}{
            $backtrack(E) :={p}$\;
            \While{$\exists p \in (backtrack(E) \backslash Sleep)$}{
                \ForEach{$e \in dom(E)$ such that $e \lesssim_{E.p} next_{[E]}(p)$}{
                    \Let{$E' = pre(E,e)$}
                    \Let{$u = notdep(e,E).p$}
                    \If{$I_{[E']}(u) \cap backtrack(E') = \emptyset$}{
                        add some $q' \in I_{[E']}(u) \text{ to } backtrack(E')$\;
                    }
                }
                \Let{$Sleep' := \{q \in Sleep \mid E \models p \diamondsuit q \} $}
                $Explore(E.p, Sleep')$\;
                add $p$ to $Sleep$\;

            }
        }
    }
\end{algorithm}

Ένα βήμα εκτέλεσης $Explore(E, Sleep)$ είναι υπεύθυνο για τις εξερευνήσεις όλων των ιχνών Mazurkiewicz
που αρχίζουν με το πρόθεμα $E$. Αυτές οι εξερευνήσεις αρχίζουν με την προετοιμασία του $backtrack(E)$ με μια αυθαίρετη ενεργοποιημένη διαδικασία
που δεν είναι στο σετ ύπνου ($Sleep$). Από αυτό το σημείο προς τα εμπρός, για κάθε διαδικασία $p$ που υπάρχει στο $backtrack(E)$
source-DPOR θα εκτελέσει δύο κύριες φάσεις.

Κατά την πρώτη φάση (ανίχνευση αγώνα), βρίσκουμε όλα τα συμβάντα $e$ που συμβαίνουν στο $E$ (δηλ., $e \in dom(E)$) τα οποία είναι αγωνιστικά
με το επόμενο συμβάν του $p$, και αυτός ο αγώνας μπορεί να αντιστραφεί ($e \lesssim_{E.p} next_{[E]}(p)$). Για κάθε τέτοιο συμβάν $e$, εμείς
προσπαθούμε να αντιστρέψουμε αυτόν τον αγώνα εξασφαλίζοντας ότι το επόμενο συμβάν του $p$ γίνεται πριν από το $e$ ή χρησιμοποιώντας τον συμβολισμό
του αλγορίθμου, ότι μια ακολουθία ισοδύναμη με $E.notdep(e,E).p.proc(e).z$ ($z$ είναι οποιαδήποτε συνέχιση της ακολουθίας εκτέλεσης)
διερευνήθηκε.
Ένα τέτοιο ίχνος θα μπορούσε να διερευνηθεί λαμβάνοντας το επόμενο διαθέσιμο βήμα από οποιαδήποτε διαδικασία στο $I_{[E']}(notdep(e,E).p)$ (όπου $E'=pre(E,e)$)
στο $E'$. Επομένως, μια διαδικασία από $I_{[E']}(notdep(e,E).p)$ προστίθεται στο backtrack που έχει οριστεί στο $E'$, υπό την προϋπόθεση ότι δεν υπάρχει ήδη εκεί.

Κατά την τελευταία φάση (εξερεύνηση), ανακαλύπτουμε αναδρομικά το $E.p$. Ο ύπνος που έχει οριστεί στο $E.p$ αρχικοποιείται κατάλληλα
λαμβάνοντας τον ύπνο που έχει οριστεί στο $E$ και την κατάργηση όλων των διαδικασιών των οποίων το επόμενο βήμα εξαρτάται από το επόμενο βήμα του $p$. Αυτό εξασφαλίζει
ότι στο $E.p$ δεν θα εξετάσουμε τους αγώνες των διαδικασιών που έχουν ήδη εξεταστεί, εκτός αν αγωνιστούν με τη νέα
προγραμματισμένη διαδικασία $p$. Μετά την ολοκλήρωση της εξερεύνησης του $E.p$, προστίθεται $p$ στον ύπνο που έχει οριστεί στο $E$,
επειδή θέλουμε να αποφύγουμε την εκτέλεση ισοδύναμου ίχνους.

Πρακτικά, στο Concuerror ο αλγόριθμος είναι δομημένος διαφορετικά. Η κύρια διαφορά είναι ότι ο αλγόριθμος μπαίνει στον αγώνα
όταν η παρεμβολή έχει φτάσει στο τέλος της. Σε αυτό το σημείο όλες οι κούρσες που συνέβησαν κατά τη διεμπλοκή
ανιχνεύονται και τα σημεία εκτροπής εισάγονται στα κατάλληλα προθέματα της πλήρους ακολουθίας εκτέλεσης. Στη συνέχεια, η εξερεύνηση
συνεχίζει με την εξερεύνηση του πακέτου backtrack του μεγαλύτερου προθέματος πρώτα. Αυτό δεν επηρεάζει την αξιοπιστία του αλγορίθμου
αφού το μόνο πράγμα που αλλάζει είναι η σειρά με την οποία διερευνώνται οι νέες παρεμβολές.

Θα πρέπει να σημειώσουμε εδώ ότι $Explore(E, Sleep)$ δεν χρειάζεται καμία πρόσθετη πληροφορία από τα διάφορα προθέματα του $E$ που
δεν έχει ήδη καθιερωθεί. Ωστόσο, το $Explore(E, Sleep)$ μπορεί να προσθέσει σημεία backtrack στα διάφορα προθέματα του $E$. Αυτό
είναι ζωτικής σημασίας και πρέπει να λαμβάνεται υπόψη κατά την προσπάθεια παραλληλισμού της πηγής-DPOR.

\section{Wakeup Δέντρα}

Προκειμένου να επιτύχουμε τη βέλτιστη λειτουργία, πρέπει να αποφύγουμε εντελώς την παρεμπόδιση των παρεμβολών που έχουν υποστεί νάρκωση. Αυτό επιτυγχάνεται με
συνδυάζοντας ένα μηχανισμό που ονομάζεται tree awakeup \cite{AbdullaAronisJohnssonSagonasDPOR2014} με σύνολα πηγών.

Παρατηρήστε ότι στην πηγή-DPOR πρέπει να διερευνηθεί μια ακολουθία της μορφής $E'.notdep(e,E).p.proc(e).z$, αλλά μόνο
μια ενιαία διαδικασία από το σύνολο Αρχικών $notdep(e,E).p$ προστίθεται δυνητικά στο σύνολο backtrack.
Ως εκ τούτου, ένα κομμάτι
των πληροφοριών για το πώς να αντιστραφεί ο αγώνας χάνεται. Αυτό μπορεί να οδηγήσει σε δέσμευση σετ ύπνου, καθώς θα μπορούσε να διερευνηθεί μια εναλλακτική αλληλουχία
αντι αυτου. Διαισθητικά, τα δέντρα αφύπνισης κρατούν με τη μορφή ενός δέντρου τα θραύσματα που πρέπει να εξερευνηθούν με τη σειρά
για να εξερευνήσετε τις απαραίτητες παρεμβολές, αποφεύγοντας ταυτόχρονα την αποτροπή του ύπνου.

Προκειμένου να ορίσουμε δέντρα αφύπνισης, παρουσιάζουμε πρώτα τις γενικεύσεις του
τις έννοιες των Αρχικών και των Αδύναμων Αρχικών, ώστε να μπορούν να περιέχουν ακολουθίες διαδικασιών αντί μόνο διαδικασιών:

\begin{itemize}
    \item $v \sqsubseteq_{[E]} w $ denotes that exists a sequence $v'$ such that $E.v.v'$ and $E.w$ are execution
    sequences with the relation $E.v.v' \simeq E.w$. What this means is that after $E$, $v$ is a possible
    way to start an execution that is equivalent to $w$. To connect this to the concept of Initials we have
    $p \in I_{[E]}(w)$ iff $p \sqsubseteq_{[E]} w $.
    \item $v \sim_{[E]} w $ denotes that exist sequences $v'$ and $w'$ such
    that $E.v.v'$ and $E.w.w'$ are execution sequences with the relation $E.v.v' \simeq E.w.w'$.
    What this means is that after $E$, $v$ is a possible way to start an execution that is equivalent to $E.w.w'$.
    To connect this to the concept of Weak Initials we have $p \in WI_{[E]}(w)$ iff $p \sim_{[E]} w $.
\end{itemize}

\begin{definition}{(Ordered Tree)}\label{def:Ordered}\\
Ένα $ordered$ $tree$ είναι ένα ζεύγος $\langle B , \prec \rangle$, όπου το B (το σύνολο των κόμβων) είναι ένα πεπερασμένο πρόθεμα-κλειστό
σύνολο ακολουθιών διαδικασιών με την κενή ακολουθία $\langle\rangle$ να είναι η ρίζα.
Τα παιδιά ενός κόμβου $w$, του τύπου $w.p$ για κάποιο σύνολο διαδικασιών $p$, διατάσσονται από το $\prec$.
Στο $\langle B , \prec \rangle$, μια τέτοια παραγγελία μεταξύ παιδιών έχει επεκταθεί στο σύνολο
τάξη $\prec$ στο $B$ αφήνοντας το $\prec$ να είναι η επαγόμενη σχέση μετά την παραγγελία μεταξύ των κόμβων στο $B$.
Αυτό σημαίνει ότι αν τα παιδιά $w.p_1$ και $w.p_2$ παραγγέλλονται ως $w.p_1 \prec w.p_2$,
τότε $w.p_1 \prec w.p_2 \prec w $ στην επαγόμενη μετά την παραγγελία.
\end{definition}

\begin{definition}{(Wakeup Tree)}\\
Αφήστε το $E$ να είναι ακολουθία εκτέλεσης και $P$ ένα σύνολο διαδικασιών. ένα $wakeup$ $tree$ μετά από $\langle E , P \rangle$
είναι ένα διατεταγμένο δέντρο $\langle B , \prec \rangle$, για το οποίο διατηρούνται οι ακόλουθες ιδιότητες:
\ begin {itemize}
\ item $WI_{[E]}(w) \cap P = \emptyset$ για κάθε φύλλο $w$ του $B$.
\ item Για κάθε κόμβο στο $B$ της φόρμας $u.p$ και $u.w$ έτσι ώστε $u.p \prec u.w$ και $u.w$ να είναι ένα φύλλο
η ιδιότητα $p \not \in WI_{[E.u]}(w)$ πρέπει να ισχύει.
\ end {itemize}
\end{definition}

\subsection{Λειτουργίες στα δέντρα αφύπνισης}



Μια σημαντική λειτουργία που χρησιμοποιείται από τον βέλτιστο αλγόριθμο DPOR είναι η εισαγωγή νέων αρχικών θραυσμάτων παρεμβολών,
που πρέπει να διερευνηθούν, στο δέντρο αφύπνισης.

Λαμβάνοντας υπόψη ένα δέντρο awakeup $\langle B , \prec \rangle$ μετά από $\langle E , P \rangle$ και κάποια ακολουθία $w$ με
Το $E.w$ είναι μια ακολουθία εκτέλεσης τέτοια ώστε $WI_{[E]}(w) \cap P = \emptyset$, χρησιμοποιούνται οι ακόλουθες ιδιότητες
καθορίστε το $insert_{[E]}(w,\langle B , \prec \rangle)$:

\begin{itemize}
    \item $insert_{[E]}(w,\langle B , \prec \rangle)$ is also a wakeup tree after $\langle E , P \rangle$.
    \item Any leaf of $\langle B , \prec \rangle$ remains a leaf of $insert_{[E]}(w,\langle B , \prec \rangle)$.
    \item $insert_{[E]}(w,\langle B , \prec \rangle)$ contains a  leaf $u$ with $u \sim_{[E]} w$.
\end{itemize}

Αφήστε το $v$ να είναι το μικρότερο (σύμφωνα με τη σειρά $\prec$) στο $B$ με $v \sim_{[E]} w$. Η επιχείρηση
Το $insert_{[E]}(w,\langle B , \prec \rangle)$ μπορεί να ληφθεί ως $\langle B , \prec \rangle$, με την προϋπόθεση ότι
$v$ είναι ένα φύλλο ή προσθέτοντας $v.w'$ ως φύλλο και διατάζοντας το μετά από όλους τους υπάρχοντες κόμβους στο $B$ της μορφής $v.w''$,
όπου $w'$ είναι η συντομότερη ακολουθία με $w \sqsubseteq_{[E]} v.w'$.

Ας περιγράψουμε επίσης τη λειτουργία $subtree(\langle B , \prec \rangle, p)$. Για ένα δέντρο αφύπνισης $\langle B , \prec \rangle$
και μια διαδικασία $p \in B$, $subtree(\langle B , \prec \rangle), p)$ χρησιμοποιείται για να δηλώσει το
subtree του $\langle B , \prec \rangle$ με ρίζες στο $p$. Πιο τυπικά,$subtree(\langle B , \prec \rangle), p) 
= \ langle B ', \ prec' \ rangle$ where $B '= \ {w \ mid p.w \ στο Β \} $ and $ \ prec'$ is the extension of $ \ prec$ to $B'$.

\section{Optimal-DPOR Αλγόριθμος}

Εδώ παρουσιάζεται ο βέλτιστος αλγόριθμος DPOR όπως περιγράφεται στο αρχικό του έγγραφο \cite{AbdullaAronisJohnssonSagonasDPOR2014}.

\SetKwProg{Fn}{Function}{}{}
\SetKwHangingKw{Let}{let}
\begin{algorithm}
    \caption{Βέλτιστη-DPOR}
    \label{optimal}
    \Fn{Explore($E$,$Sleep$,$WuT$)}{
        \uIf{$enabled(s_{[E]}) = \emptyset$}{
            \ForEach{$e,e' \in dom(E)$ such that ($e \lesssim_{E} e'$)}{
                \Let{$E' = pre(E,e)$}
                \Let{$v = notdep(e,E).proc(e')$}
                \If{$sleep(E') \cap WI_{[E']}(v)= \emptyset$}{
                    $insert_{[E']}(v,wut(E'))$\;
                }
            }
        }
    \Else {
        \uIf{$WuT \not = \langle \{ \langle \rangle \}, \emptyset \rangle$}{
            $wut(E) := WuT$\;
        }
        \Else {
            choose $p \in enabled(s_{[E]})$\;
            $wut(E) := \langle \{ p \}, \emptyset \rangle $\;
        }
        $sleep(E) := Sleep$\;
        \While{$\exists p \in wut(E)$}{
            \Let{ $p = min_{\prec}\{ p \in wut(E)\}$}
            \Let{$Sleep' := \{q \in sleep(E) \mid E \models p \diamondsuit q \} $}
            \Let{$WuT' = subtree(wut(E), p)$}
            $Explore(E.p, Sleep', WuT')$\;
            add $p$ to $sleep(E)$\;
            remove all sequences of form $p.w$ from $wut(E)$\;
        }
    }
    }
\end{algorithm}

Ομοίως, με τους άλλους αλγορίθμους, το βέλτιστο-DPOR έχει δύο διαφορετικές φάσεις: ανίχνευση αγώνα και εξερεύνηση κατάστασης.
Ωστόσο, ο αλγόριθμος είναι δομημένος διαφορετικά. Με τον ίδιο τρόπο που η πηγή-DPOR είναι δομημένη στο Concuerror,
το βέλτιστο-DPOR ανιχνεύει μόνο τους αγώνες όταν έχει επιτευχθεί μια μέγιστη ακολουθία εκτέλεσης (δηλαδή, δεν υπάρχει αριθ
ενεργοποιημένες διαδικασίες). Αυτό είναι απαραίτητο επειδή η προϋπόθεση για την εισαγωγή νέων δέντρων αφύπνισης είναι μόνο
ισχύει όταν το κομμάτι που πρόκειται να εισαχθεί περιέχει όλα τα συμβάντα στις πλήρεις εκτελέσεις αυτού
δεν συμβαίνουν μετά από $e$ και αυτές που συμβαίνουν μετά $e$.

Η φάση ανίχνευσης αγώνων λειτουργεί ως επί το πλείστον παρόμοια με την πηγή-DPOR. Οι κύριες διαφορές έχουν να κάνουν με το γεγονός ότι
απαιτούμε τη γνώση του συνόλου ύπνου για κάθε πρόθεμα $E'$ και ότι χρησιμοποιούνται οι έννοιες των Αδύναμων Αρχικών αντί για
τα αρχικά για να καθορίσουν αν ένα θραύσμα πρόκειται να εισαχθεί στο δέντρο αφύπνισης, το οποίο έχει τις ρίζες του στο πρόθεμα $E'$.

Στη φάση εξερεύνησης μιας μη μεγίστης ακολουθίας εκτέλεσης, το δέντρο αφύπνισης αυτής της ακολουθίας αρχικοποιείται στο
δεδομένου $WuT$. Εάν το $WuT$ είναι άδειο, τότε επιλέγεται μια αυθαίρετα ενεργοποιημένη διαδικασία, με τον ίδιο τρόπο που θα εφαρμοζόταν για τους μη βέλτιστους αλγορίθμους.
Στη συνέχεια, για κάθε διαδικασία που υπάρχει στο $WuT$ η λειτουργία εξερεύνησης θα καλείται αναδρομικά, με την κατάλληλη
subtree του $wut(E)$. Αυτό εγγυάται την διερεύνηση του πλήρους τμήματος. Μετά την ολοκλήρωση της αναδρομικής κλήσης,
οι ακολουθίες που εξερευνήθηκαν αφαιρούνται από το δέντρο αφύπνισης. Τα σύνολα ύπνου αντιμετωπίζονται με παρόμοιο τρόπο με τα προηγούμενα
αλγορίθμους.

Όπως υποδηλώνει το όνομα, ο optimal-DPOR είναι βέλτιστο υπό την έννοια ότι ποτέ δεν ερευνά δύο μέγιστες ακολουθίες εκτέλεσης
που ανήκουν στο ίδιο ίχνος Mazurkiewicz, καθώς μπορεί να αποδειχθεί ότι καμία παρεμβολή δεν είναι sleep-set blocked
\cite{AbdullaAronisJohnssonSagonasDPOR2014}.
