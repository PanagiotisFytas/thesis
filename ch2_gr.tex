\chapter{Θεωρητικό Υπόβαθρο}
\label{sec:background}

\section{Η γλώσσα Erlang}

Η Erlang είναι μια δηλωτική γλώσσα προγραμματισμού με ενσωματωμένη υποστήριξη για ταυτοχρονισμό,
αντοχή σφάλματος, επαναφόρτωση κώδικα και αυτόματη διαχείριση μνήμης.
Η Erlang αναπτύχθηκε αρχικά από την Ericsson το 1986 με σκοπό τον προγραμματισμό
βιομηχανικά συστήματα τηλεπικοινωνιών. Ωστόσο, αργότερα συνειδητοποίησε ότι
ήταν επίσης κατάλληλο για εφαρμογές πραγματικού χρόνου \cite{Armstrong:1996:CPE:229883}.
Το 1998, η Erlang / OTP (Open Telecom Platform) απελευθερώθηκε ως open source και έκτοτε χρησιμοποιήθηκε
εμπορικά από διάφορες εταιρείες, συμπεριλαμβανομένης της Ericsson, για μια μεγάλη ποικιλία εφαρμογών μεγάλης κλίμακας.

\subsection{Ταυτόχρονη Erlang}

Η κύρια δύναμη της Erlang απορρέει από την ενσωματωμένη υποστήριξη ταυτόχρονης λειτουργίας. Στον πυρήνα αυτού
είναι οι διεργασίες Erlang, όπου η καθεμία έχει τον δικό του μετρητή προγραμμάτων, το λεξικό διαδικασίας και τη στοίβα κλήσεων.
Επιπλέον, η Erlang υλοποιεί τις διαδικασίες της μέσω του συστήματος runtime του BEAM (VM της Erlang)
και επομένως δεν έχουν αντιστοιχιστεί σε λειτουργικά συστήματα. Αυτές οι διαδικασίες χρησιμοποιούν ελάχιστη μνήμη, μπορούν να αλλάξουν την εργασία πολύ γρήγορα,
μπορεί να τρέξει παράλληλα και χιλιάδες από αυτά μπορούν να υπάρχουν σε ένα μόνο μηχάνημα.
Μια διαδικασία αναγνωρίζεται παγκοσμίως από το Pid (αναγνωριστικό διαδικασίας).

Η επικοινωνία Erlang βασίζεται κυρίως στη μετάδοση μηνυμάτων, καθώς η κατάσταση των διαδικασιών Erlang είναι
(`` ως επί το πλείστον '') δεν είναι κοινόχρηστο.Συνεπώς, ο χειριστής $``!"$ μπορεί να χρησιμοποιηθεί για την ασύγχρονη αποστολή μηνυμάτων μεταξύ διαδικασιών,
που μπορεί να είναι οποιουδήποτε τύπου δεδομένων. Το μήνυμα τοποθετείται στο `` mailbox '' (ουρά μηνυμάτων) της διαδικασίας λήψης,
μέχρι να εξαχθεί από ένα \textit{receive}
έκφραση. Η έκφραση \textit{receive} χρησιμοποιεί αντιστοίχιση προτύπων για σάρωση του γραμματοκιβωτίου με εντολή FIFO
για ένα μήνυμα που ταιριάζει με αυτό το μοτίβο. Αν δεν βρεθεί τέτοιο μήνυμα, η διαδικασία λήψης αποκλείεται στο \textit{receive},
περιμένοντας να σταλεί ένα νέο μήνυμα ή να υπάρξει ένα χρονικό όριο, σε περίπτωση που η έκφραση \textit{receive} είχε ένα τμήμα \textit{after}.

Η εκκίνηση μιας διαδικασίας μπορεί να γίνει αποτελεσματικά μέσω του BIF (ενσωματωμένη συνάρτηση) (\textit{spawn/1})
(και των παραλλαγών της).
Καλώντας αυτή τη συνάρτηση, δημιουργείται μια νέα ταυτόχρονη διαδικασία erlang προκειμένου να αξιολογηθεί η λειτουργία
που καθορίζονται στα επιχειρήματα του \textit{spawn}. Το PID αυτής της νέας διαδικασίας είναι η τιμή επιστροφής του \textit{spawn}
λειτουργία.

Συχνά υποστηρίζεται ότι την Erlang δεν έχει κοινή μνήμη μεταξύ διαφορετικών διαδικασιών \cite{Armstrong:2007:PES:1403889}
και η επικοινωνία μεταξύ των διαδικασιών στηρίζεται αποκλειστικά
μετάβαση μηνύματος. Ωστόσο, αυτό δεν είναι εξ ολοκλήρου αληθές, δεδομένου ότι είναι δυνατόν για διαφορετικές διαδικασίες
πρόσβαση στην ίδια μνήμη μέσω της ενότητας ETS (Erlang Term Storage).

\subsection{Distributed Erlang}

Ένας κόμβος Erlang είναι ένα runtime σύστημα Erlang που περιέχει μια πλήρη εικονική μηχανή που περιέχει το δικό του
το δικό του χώρο διευθύνσεων και το σύνολο των διαδικασιών \cite{Armstrong:2007:PES:1403889}. Ένας κόμβος έχει αντιστοιχιστεί σε ένα όνομα
η μορφή ``name@host'' .Οι κόμβοι Erlang μπορούν να συνδεθούν μεταξύ τους χρησιμοποιώντας cookies και μπορούν να επικοινωνήσουν
μέσω του δικτύου. Τα Pids συνεχίζουν να είναι μοναδικά σε διαφορετικούς κόμβους (σε παγκόσμιο επίπεδο). Εντούτοις, μέσα
δύο διαφορετικοί κόμβοι, δύο διαφορετικές διεργασίες μπορούν να έχουν το ίδιο τοπικό Pid.

Τα προγράμματα Distributed Erlang μπορούν να εκτελούνται σε διαφορετικούς κόμβους. Μια διαδικασία Erlang μπορεί να γεννηθεί σε οποιαδήποτε
κόμβος, τοπικό ή απομακρυσμένο. Όλα τα πρωταρχικά ($``!"$, \textit{receive}, κ.λπ.) λειτουργούν μέσω του δικτύου με τον ίδιο τρόπο που
στον ίδιο κόμβο.

\section{Stateless Model Checking και Partial Order Reduction}

Προκειμένου να βρούμε σφάλματα σε  concurrent προγράμματα, πρέπει να ελέγξουμε όλα τα δυνατά interleaving, (όλους τους δυνατούς τρόπους που ένα πρόγραμμα μπορεί να εκτελεστεί)
που το πρόγραμμα μπορεί να παράξει. Συνήθως αυτά τα λάθη προκύπτον υπό συγκεκριμένες συνϑήκες τις οποίες ο προγραμματιστής δεν έλαβε υποψιν, κάνοντας τον εντοπισμό και
διόρθωσή τους πολύ δύσκολες.
Το Stateless model checking βασίζεται στην ιδέα της οδήγησης του προγράμματος σε όλα τα δυνατά interleavings. Δυστυχώς αυτή η προσέγγιση υποφέρει από το state explosion,
δηλαδή ο αριθμός όλων των δυνατών interleavings αυξάνει εκθετικά σε σύγκριση με το μέγεθος του προγράμματος και τον αριθμό τον νημάτων ή διεργασιών.
Πολλές προσεγγίσεις έχουν προταθεί προκειμένου να λύσουνν το συγκεκριμένο πρόβλημα όπως το partial order reduction \cite{Godefroid1996} και οι τεχνικές περιορισμού-οριοθέτησης. 

Το Partial order reduction στοχεύει την μείωση του αριθμου των interleavings που εξερευνώνται με την εξάλειψη ισοδύναμων interleavings.
Κάθε interleaving μπορεί να παρουσιαστεί σαν ένα ίχνος (trace).
Αυτά τα ισοδύναμα ίχνη παράγονται από την αντιστροφή ανεξάρτητων γεγονότων τα οποία δεν επηρεάζουν το αποτέλεσμα του προγράμματος. Για παράδειγαμ η δρομολογήση δύο νημάτων τα οποία
διαβάζουν μια τοπική μεταβλητή (local variable) μπορεί να αντιστραφεί καθώς το αποτέλεσμα αυτών των ενεργειών δεν επηρεάζεται από τη σειρά που αυτές θα γίνουν.
Υπάρχουν δύο τρόπου με του οποίους μπορούμε να κάνουμε partial order reduction. Ο πρώτος είναι το 
static partial order reduction \cite{Static1997} όπου η εξαρτήσεις μεταξύ των νημάτνω εντοπίζονται πρην την εκτέλεση του concurrent προγράμματος. 
Η δεύτερη προσέγγιση είναι το  Dynamic partial order reduction (DPOR) \cite{FlanaganDPOR} το οποίο παρατηρεί τις εξαρτήσεις του προγράμματος κατά την εκτλέση του.

\section{Notation}

Πριν προχωρήσουμε βαθύτερα στο dynamic partial order reduction είναι πολύ σημαντικό να εξηγήσουμε τη σημειογραφία που θα χρησιμοποιήσουμε.
Μια ακολουθία εκτέλεσης $E$ ενός συστήματος που αποτελείται από περατό αριθμό βημάτων των διεργασιών του εκτελείται από την αρχική κατάσταση 
$s_0$. Δεδομένου ότι κάθε βήμα είναι ντερμινιστικό, μια ακολουθία εκτελέσεων $E$ χαρακτιρίζεται κατά μοναδικό τρόπο απο την ακολουθία των διεργασίων που εκτελούν εντολές στο $E$.
Για παράδειγμα, το $p.p.q$ συμβολίζει την εκτέλεση της ακολουθίας όπου το $p$ εκτελεί δύο βήματα, ακολουθούμενο από ένα βήμα του $q$.
Αυτή η ακολουθία από βήματα στο $E$ ορίζει μόναδικά και το global state του συστήματος μετά την εκτέλεση του $E$, που συμβολίζεται με $s_{[E]}$. 
Για ένα state $s$, το $enabled(s)$ συμβολίζει το σύνολο των διεργασιών $p$ 
που είναι ενεργές στο $s$ (για τις οποίες η εκτέλεση $p(s)$ ορίζεται). Χρησιμοποιούμε το $.$ για να συμβολίσουμε την ένωση (concatenation) ακολουθιών απο διεργασίες.
Έτσι, αν η $p$ δεν είναι μπλοκαρισμένη μετά το $E$, τότε $E.p$ είναι μια ακολουθία εκτελέσεων.
Ένα γεγονός στο $E$ είναι μια συγκεκριμένη εμφάνιση μια διεργασίες στο $E$.
Χρησιμοποιούμε το $\langle p,i \rangle$ για να συμβολίζουμε το i-οστό γεγονός μιάς διεργασίας $p$ στην εκτέλεση $E$. 
Με άλλα λόγια, το γεγονός $\langle p,i \rangle$ είναι το i-οστό βήμα τη διεργασίας $p$ στην εκτέλεση $E$. 
Με το $dom(E)$ συμβολίζουμε το σύνολο των γεγονότων $\langle p,i \rangle$ τα οποία ανήκουν στο $E$, i.e., $\langle p,i \rangle \in dom(E)$ ανν $E$
περιέχει τουλάχιστον $i$ βήματα του $p$. Θα χρήσιμποιούμε τα $e,e',...$ , για αναφερόμαστε σε διάφορα γεγονότα. 
Το $proc(e)$ συμβολίζει τη διερτασία $p$ ενός γεγονότος $e = \langle p, i \rangle$.
Αν $E.w$ είναι μια εκτέλεση, που προέκυψε από τη συνένωση του $E$ και του
$w$, τότε το $dom_{[E]}(w)$ θα είναι $dom(E.w) \ dom(E)$, δηλαδή τα γεγονότα στο
$E.w$ τα οποία ανήκουν στο $w$. Μια ειδική περίπτωση είναι η εξής: χρησιμοποιούμε το  $next_{[E]}(p)$ για να συμβολίσουμε το
$dom_{[E]}(p)$.
Το $<_E$ συμβολίζει τη συνολική διάταξη μεταξύ των γεγονότων του $E$, δηλαδή, το
$e <_E e'$ συμβολίζει ότι το  $e$ συμβαίνει πριν από το $e'$ στο $E$. Τέλος
χρησιμοποιούμε το $E'\leq E$ για να συμβολίσουμε ότι η ακολουθία $E'$ είναι
πρόθεμα της ακολουθίας $E$.

\section{Event Dependencies}

Μια από τις πιο σημαντικές έννοιες όταν χρησιμοποιούμε έναν αλγόριθμο που κάνει αναζήτηση σε όλο τον χώρο καταστάσεων των διαφόρων δρομολογήσεων είναι η σχέση
happens-before σε μια ακολουθία εκτέλεσης. Συνήθως αυτή η σχέση συμβολίζεται με $\rightarrow$. Για παράδειγμα η σχέση $\rightarrow$ 
για δύο γεγονότα $e,e'$ στο $dom(E)$ είναι αληθής τότε το γεγονός $e$ συμβαίνει πριν το $e'$. Αυτή η σχέση συνήθως εμφανίζεται στην ανατλλαγή μηνυμάτνων όταν το  $e$ 
είναι η μετάδοση μηνύματος και το $e'$ είναι το γεγονός της λήψης του μηνύματος. Για παράδειγμα στο Nidhugg το $e \rightarrow e'$ δε θα ήταν αληθές αν τουλάχιστον ένα από τα δύο γεγονότα
δεν ήταν write operation στην ίδια μοιραζόμενη μεταβλητή. Είναι λογικό κάθε DPOR αλγόριθμος να μπορεί να προσδώσει τέτοιες happens-before σχέσεις. 
Πρακτικά η happens-before ανάθεση υλοποιείται με τη χρήση vector clocks.

\begin{definition}{(happens-before ανάθεση)}
    Μια happens-before ανάθεση, η οποία αναθέτει μια μοναδική σχέση
    happens-before $\rightarrow E$ σε κάθε ακολουθία εκτέλεσης
    $E$, είναι έγκυρη αν ικανοποιεί τις ακόλουθες ιδιότητες για κάθε $E$.
    \begin{enumerate}
        \item Το $\rightarrow_{E}$ είναι μια μερική διάταξη στο $dom(E)$, που περιλαμβάνεται στο $<_E$. Με άλλα λόγια κάθε δρομολόγηση είναι μέρος μια μερικής διάταξης που μπορεί να παράξει το πρόγραμμα.
        \item Τα βήματα εκτέλεση κάθε διεργασίας είναι πλήρως διατεταγμένα, δηλαδή
        $\langle p,i \rangle \rightarrow_E \langle p,i+1 \rangle$ όποτε ισχύει $\langle p, i+1 \rangle \in dom(E)$.
        \item Αν $E'$ είναι πρόθεμα του $E$ τότε $\rightarrow_E$ και $\rightarrow_{E'}$ είναι ίδια στο $dom(E')$.
        \item Κάθε γραμμικοποίηση (linearization) $E'$ of $\rightarrow_E$ στο $dom(E)$ είναι μια ακολουθία εκτέλεσης ακριβώς ίδια με τη “happens-before” σχέση.
$\rightarrow_{E'}$ as $\rightarrow_E$. Αυτό σημαίνει ότι η σχέση $\rightarrow_E$ επάγει ένα σύνολο
από ισοδύναμες ακολουθίες εκτέλεσης, όλες με την ίδια “happens-before” σχέση. 
Το $E \simeq E'$ συμβολίζει ότι τα $E$ και $E'$ είναιe
γραμμικοποιήσεις της ίδιας “happens-before” σχέσης, και το $[E] \simeq$ 
συμβολίζει την ισοδυναμία στην περίπτωση του E.
    \item Αν $E \simeq E'$ τότε $s_{[E]} = s_{[E']}$ (δύο ισοδύναμα traces θα οδηγήσουν στο ίδιο state).
    \item Για μια ακολουθία $E, E'$ και $w$, ώστε η $E.w$  είναι μια ακολουθία εκτέλεσης, έχουμε ότι $E \simeq E'$  ανν $E.w \simeq' E'.w$.
    \end{enumerate}
\end{definition}

\section{Ανεξαρτηστία και Ανταγωνισμός}

Μπορούμε πλέον να ορίσουμε την ανεξαρτησία μεταξύ υπολογισμών. Αν
$E.p$ και $E.w$ είναι δύο ακολουθίες εκτέλεσης, τότε το $E \models p\diamondsuit w$ συμβολίζει
ότι το $E.p.w$ είναι μια ακολουθία εκτέλεσης τέτοια ώστε $next_{[E]}(p) \not \rightarrow_{E.p.w} e$
για κάθε $e \in dom([E.p])(w)$. Με άλλα λόγια, το $E \models p \diamondsuit w$ δηλώνει ότι
το επόμενο γεγονό του $p$ δε θα “συμβεί πριν” από κάποιο άλλο στο $w$
στην ακολουθία εκτέλεσης $E.p.w$. Διαισθητικά, αυτό σημαίνει ότι το $p$ είναι
ανεξάρτητο από το $w$ μετά το $E$. Στην ειδική περίπτωση όπου το  $w$ περιέχει
μόνο μια διεργασία $q$, τότε το $E \models p \diamondsuit q$ συμβολίζει ότι τα επόμεντα βήματα των 
$p$ και $q$ είναι ανεξάρτητα μετά το $E$. Το $E'\models p \diamondsuit w$ συμβολίζει ότι το 
$E \not \models p \diamondsuit w$ δεν ισχύει.

Για μια ακολουθία $w$ με $p \in w$, let $w \backslash p$ συμβολίζουμε την ακολουθία
$w$ με την πρώτη εμφάνσιση του $p$ να έχει αφαιρεθεί, και το $w \uparrow p$ συμβολίζει
το πρόθεμα του $w$ μέρχι αλλά χωρίς να συμπεριλαμβάνει την πρώτη εμφάνιση του $p$. Για
μια ακολουθία εκτέλεσης $E$ και ένα γεγονός $e \in  dom(E)$, έστω ότι το $pre(E,e)$
συμβολίζει το πρόθεμα του $E$ μέχρι αλλά χωρίς να συμπεριλαμβάνει το $e$. Για μια
ακολουθία εκτέλεσης $E$ και ένα γεγονός $e \in E$, το $notdep(e, E)$ είναι η
υπακολουθία του $E$ που αποτελείται από τα γεγονότα που συμβαίνουν μετά το $e$ αλλά δε 
“συμβαίνουν μετά” το $e$ (δηλαδή τα γεγονότα  $e'$ που συμβαίνουν μετά το $e$ για τα οποία ισχύει
$e \not \rightarrow_E e'$).


Μια κεντρική έννοια στους περισσότερους DPOR αλγορίθμου είναι αυτή του ανταγωνισμού.
Διαισθητικά, δύο γεγονότα $e$ και $e'$ σε μια ακολουθία εκτέλεσης $E$, όπου το
$e$ συμβαίνει πριν το $e'$ στο $E$, συναγωνίζοναι αν
\begin{itemize}
\item Το $e$ συμβαίνει πριν το $e'$ στο  $E$, και
\item τα $e$ και $e'$ είναι ταυτόχρονα, δηλαδή υπάρχει μια ισοδύναμη ακολουθία εκτέλεσης 
$E' \simeq E$ στην οποία τα $e$ και $e'$ είναι γειτονικά.
\end{itemize}
Τυπικά, έστω ότι τα $e \lessdot_E e'$ συμβολίζουν ότι  $proc(e) \not = proc(e')$, ότι $e \rightarrow_E e'$,
και ότι δεν υπάρχει γεγονός  $e'' \in dom(E)$, διαφορετικό από τα $e'$ και $e$,
τέτοιο ώστε $e \rightarrow_E e'' \rightarrow_E e'$.

Όποτεδήποτε ο DPOR εντοπίζει συναγωνισμό, ελέγχει αν τα γεγονότα που συναγωνίζονται μπορούν να εκτελεστούν σε αντίστροφη σειρά.
Δεδομένου ότι τα γεγονότα συνδέονται με σχέσεις happens-before, μπορεί να οδηγηθούμε σε διαφορετικά
global state: έτσι ο αλγόριθμος πρέπει να προσπαθήσει να εξερευνήσει την αντίστοιχη ακολουθία εκτέλεσης
Έστω ότι το $e \lesssim_E e'$ συμβολίζει ότι
$e \lessdot_E e'$, και ότι ο συναγωνισμός μπορεί να αντιστραφεί. Τυπικά, αν $E' \lesssim E$
και το $e$ συμβαίναι ακριβώς πριν το $e'$ στο $E'$, τότε η $proc(e')$ δεν ήταν μπλοκαρισμένη
πριν την εμφάνιση του $e$.


\section{Επισκόπηση Concuerror}

O Concuerror \cite{6569727, Gotovos:2011:TDC:2034654.2034664} είναι ένα εργαλείο που χρησιμοποιεί διάφορα stateless model checking μοντέλα προκειμένου να συστηματικά
δοκιμάστε ένα πρόγραμμα Erlang, με στόχο να ανιχνεύσετε και να αναφέρετε τα σφάλματα χρόνου εκτέλεσης που σχετίζονται με τη συναναστροφή.
Συγκεκριμένα, ο Concuerror περιηγείται στο χώρο κατάστασης ενός προγράμματος, κάτω από μια δεδομένη δοκιμαστική σουίτα με καθορισμένη είσοδο,
για να ελέγξετε αν εμφανίζονται ορισμένα σφάλματα σε συγκεκριμένες παρεμβολές ή για να επαληθεύσετε την απουσία τυχόν σφαλμάτων. Τέτοια σφάλματα περιλαμβάνουν αφύσικες διεργασίες εξόδου, ασυμβίβαστες
εξαιρέσεις, παραβιάσεις ισχυρισμών και αδιέξοδα. Η λειτουργικότητα του Concuerror μπορεί να περιγραφεί κυρίως μέσω των κύριων στοιχείων του:
του Instrumenter, του Scheduler και του Logger.

\subsection{Instrumenter}

Ο Concuerror χρησιμοποιεί τον κώδικα ενός προγράμματος χωρίς να χρειάζεται να κάνει τροποποίηση στο Erlang VM. Αντ 'αυτού, αυτό
χρησιμοποιεί μια πηγή για μετάφραση πηγής που προσθέτει σημεία προτίμησης σε διάφορα σημεία του κώδικα ενός προγράμματος.
Όταν η εκτέλεση ενός προγράμματος φτάσει σε ένα σημείο εξαγοράς, η διαδικασία θα αποδώσει την εκτέλεση του με αποκλεισμό
σε μια εντολή λήψης, μέχρι να σταλεί ένα μήνυμα συνέχειας από το Scheduler.

Αυτό επιτρέπει τον έλεγχο του προγραμματισμού των διαδικασιών ενός προγράμματος και, ως εκ τούτου, την αναδημιουργία ενός συγκεκριμένου
interleaving. Επιπλέον, αυτό επιτρέπει την τροποποίηση συγκεκριμένων BIF που αλληλεπιδρούν με την παγκόσμια
κατάσταση ενός προγράμματος, εισάγοντας ένα σημείο προτίμησης πριν από αυτές τις κλήσεις λειτουργίας και τον έλεγχο της εκτέλεσης τους.

\subsection{Scheduler}

Προκειμένου να διερευνηθεί ο πλήρης χώρος ενός παράλληλου προγράμματος, είναι ζωτικής σημασίας να μπορέσουμε να
`` αναγκάσουμε '' συγκεκριμένους προγραμματισμούς (interleavings) των διαδικασιών του. Ο Scheduler είναι υπεύθυνος για τον έλεγχο
της εκτέλεση των διαδικασιών, για την παραγωγή των απαιτούμενων παρεμβολών και ταυτόχρονα
για να ελέγξει και χειριστεί πιθανά σφάλματα που μπορεί να προκύψουν.

Ο Scheduler είναι επίσης υπεύθυνος για τον προσδιορισμό ποιων διεμπλοκών πρέπει να ελεγχθούν. Αυτό έγινε
με την εφαρμογή διάφορων αλγορίθμων DPOR (persistent-DPOR, source-DPOR, optimal-DPOR). Ο προεπιλέγμενος
αλγόριθμος που χρησιμοποιείται σήμερα από το Concuerror είναι optimal-DPOR.
Ωστόσο, ο χρήστης μπορεί να καθορίσει την τεχνική που θα χρησιμοποιήσει το Concuerror για την αναζήτηση του χώρου κατάστασης.

Η λειτουργία του Scheduler μπορεί να χωριστεί σε δύο βασικά μέρη: \textit{the exploration phase} και
το \textit{planning phase} (σύμφωνα με τους περισσότερους αλγορίθμους DPOR, όπως περιγράφεται στο Κεφάλαιο \ref{dpor}).
Η φάση σχεδιασμού είναι υπεύθυνη για τον προσδιορισμό των αλληλεπιδράσεων που πρέπει να διερευνηθούν και η
φάση εξερεύνησης είναι υπεύθυνη για την παραγωγή αυτών των παρεμβολών.

\subsection{Logger}

Τα προγράμματα δοκιμών είναι άχρηστα χωρίς να παρέχουν στον χρήστη πληροφορίες σχετικά με τον τρόπο με τον οποίο δημιουργήθηκε ένα σφάλμα. Αυτό είναι
την ευθύνη του Logger. Κατά τη διάρκεια της εκτέλεσης, ο Scheduler καταγράφει πληροφορίες σχετικά με τις διερευνηθείσες παρεμβολές.
Ο Logger είναι υπεύθυνος για τη σύνταξη αυτών των πληροφοριών προκειμένου να εκτυπώσει το ίχνος ενός προγράμματος που οδήγησε σε ένα
πιθανό σφάλμα. Ταυτόχρονα, όταν χρησιμοποιείται σε λειτουργία debugging, ο Logger είναι απαραίτητος για τον εντοπισμό σφαλμάτων για τους προγραμματιστές του Concuerror.
