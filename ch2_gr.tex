\chapter{Θεωρητικό Υπόβαθρο}
\label{sec:background}

\section{Ταυτόχρονος Προγραμματισμός}

Ο ταυτόχρονος υπολογοσιμός που υλοποιείται με το πρότυπο του ταυτόχρονου προγραμματισμού είναι μια μορφή υπολογισμού όπου ξεχωριστές υπολογιστικές μονάδες εκτελούν υπολογισμούς
σε επικαλυπτόμενα χρονικά διαστήματα αντί ν ατου εκτελούν ακολουθιακά (ένας υπολογισμός τερματιζεί πριν να αρχίσει ένας άλλος).
Το προηγοόυμεν μπορεί να είναι μια ιδιότητα ενός συστήματος, ενός προγράμματος, ενός υπολογιστή ή ακόμα κι ενός δικτύου. 
Σε ένα concurrent σύστημα ένας υπολογισμός μπορεί να προχωρήσει χωρίς να περιμένει κάποιον προηγούμενο να ολοκληρωθεί. 
Η βασική πρόκληση στο σχεδιασμό ενός τέτοιου συστήματος είναι το  concurrency control: δήλαδη η διασφάληση της σωστής αλληλουχίας των υπολογισμών, η αλληλεπίδραση
ή η επικοινωνία μεταξύ των διαφορετικών υπολογιστικών μονάδων και ο συντονισμός στην πρόσβαση σε πόρους που μοιράζονται μεταξύ των διαφόρων υπολογισμών.
Στα πιθανά προβλήματα περιλαμβάνονται τα race conditions, deadlocks, livelocks και resource starvation.
Ο δρομολογιτής είναι συνήθως υπεύθυνος για την εκετέλεση ένος νήματος. Λόγω του μη ντετερμινισμού ο προγραμματιστής δεν μπορεί πάντοτε να είναι σε θέση να γνωρίζει ποιο νήμα
θα δρομολογηθεί στη συνέχεια.

Μια σημαντική ιδέα στον ταυτόχρονο προγραμματισμμό είναι η ιδέα του συνόλου των interleaving δηλαδή του συνόλου όλων την δυνατών εκτελέσεων που μπορεί να ακολουθήσει ένα πρόγραμμα.
Διαισθητικά, αν φανταστούμε μια διεργασία (πιθανότατα απειρή) ώς μια ακολουθία απο statetements (που μπορεί να έχουν προκύψει από την ``ξεδίπλωση᾽᾽ βρόχων ή  loop unfolding),
τοτε το σύνολο όλων των δυνατών interleaving των διεργασιών αποτελείται από όλες της δυνατές ακολουθίες από αυτά τα statements.

Όπως μπορούμε να συμπεράνουμε η αποσφαλμάτωση (debugging) τέτοιων προγραμμάτων μπορεί να γίνει πάρα πολύ δύσκολη. Η πρόκληση προκύπτει κυρίως από το γεγονός ότι δεν είναι πάντα
ξεκάθαρο ποιο νήμα ή διεργασία θα εκτελεστεί. Επιπλέον τα σφάλματα δεν εμφανίζονται πάντα κατα τη διάρκει του debugging καθώς μόνο ένας πολύ μικρός αριθμός από interleavings μπορεί
να οδηγεί στην εκδήλωση του σφάλματαος.

\section{Σφάλματα στο Μοντέλο του Ταυτοχρονισμού (Concurrency Errors)}
Σε αυτό το σημείο είναι σημαντικό να εισάγουμε την έννοια του concurrency error και να εξηγήσουμε πως αυτό διαφέρει από τα υπόλοιπα σφάλματα.

\begin{definition}{(Concurrency Error)}
   Ένα concurrency error είναι ένα σφάλμα που προκύπτει από τον μη ντετερμινισμό του δρομολογητή. 
\end{definition}

Ένα παράδειγμα προγράμματος που περιέχει concurrency error δίνεται στο Listing \ref{Example of concurrency error}. 
Σε αυτό το πρόγραμμα η μεταβλητή $x$ ισούται με 1 στην αρχή της εκτέλεσης του προγράμματος. Παρολ᾽ αυτά, αν το thread $zero$ δρομολογηθεί πριν το thread $divider$ 
μια διαίρεση με το μηδέν θα λάβει χώρα. Από την άλλη μεριά μια απλή διαίρεση με το 0 δεν μπορεί να θεωρηθεί concurrency error σε μια περίπτωση όπως φαίνεται στο 
Listing \ref{Example of non-concurrency error} όπου η διαίρεση με το μηδέν θα γίνει χωρίς την παρέμβαση του δρομολογητή.
%
\Code{./code/zero.c}{Example of non-concurrency error}
%
\Code{./code/zeroconc.c}{Example of concurrency error}

\section{Δοκιμή, Model Checking και Επαλήθευση}

To Dynamic software model checking είναι μια μορφή συστηματικού testing που είναι εφαρμόσιμο σε βιομηχανικού μεγέθους λογισμικό.
Πολλά εργαλεία έχουν αναπτυχθεί τις τελευταίες δεκαετίες που χρησιμοποιούν αυτή την τεχνική με στόχο concurrent και data-driven software. 
Το model checking είναι πιο απαιτητικό υπολογιστικά από το παραδοσιακό software testing καθώς προσφέρει μεγαλύτερη 
κάλυψη (coverage) του προγράμματος. Παρολ᾽ αυτά είναι φθηνότερος από γενικότερες μορφές επαληθευσης όπως το interactive theorem
proving, το οποίο προσφέρει πολύ μεγαλύτερες εγγυήσεις.
Επομένως, το  dynamic software model checking προσφέρει μια ελκυστική πρακτική που μπορεί να συγκεράσει ως ένα βαθμό το testing και formal verification. 

Το γράφημα που δίνεται στο  Figure \ref{Comparing Testing, Model Checking and Verification} \cite{TestingvsVerification} παρουσιάζει με πολύ σωστό τρόπο
τις διαφορές μεταξύ testing, model checking και verification.

\trace{testmodver.png}{Comparing Testing, Model Checking and Verification}

\section{Stateless Model Checking και Partial Order Reduction}

Προκειμένου να βρούμε σφάλματα σε  concurrent προγράμματα, πρέπει να ελέγξουμε όλα τα δυνατά interleaving, (όλους τους δυνατούς τρόπους που ένα πρόγραμμα μπορεί να εκτελεστεί)
που το πρόγραμμα μπορεί να παράξει. Συνήθως αυτά τα λάθη προκύπτον υπό συγκεκριμένες συνϑήκες τις οποίες ο προγραμματιστής δεν έλαβε υποψιν, κάνοντας τον εντοπισμό και
διόρθωσή τους πολύ δύσκολες.
Το Stateless model checking βασίζεται στην ιδέα της οδήγησης του προγράμματος σε όλα τα δυνατά interleavings. Δυστυχώς αυτή η προσέγγιση υποφέρει από το state explosion,
δηλαδή ο αριθμός όλων των δυνατών interleavings αυξάνει εκθετικά σε σύγκριση με το μέγεθος του προγράμματος και τον αριθμό τον νημάτων ή διεργασιών.
Πολλές προσεγγίσεις έχουν προταθεί προκειμένου να λύσουνν το συγκεκριμένο πρόβλημα όπως το partial order reduction \cite{Godefroid1996} και οι τεχνικές περιορισμού-οριοθέτησης
(bounding techniques) \cite{BPOR}. 

Το Partial order reduction στοχεύει την μείωση του αριθμου των interleavings που εξερευνώνται με την εξάλειψη ισοδύναμων interleavings.
Κάθε interleaving μπορεί να παρουσιαστεί σαν ένα ίχνος (trace).
Αυτά τα ισοδύναμα ίχνη παράγονται από την αντιστροφή ανεξάρτητων γεγονότων τα οποία δεν επηρεάζουν το αποτέλεσμα του προγράμματος. Για παράδειγαμ η δρομολογήση δύο νημάτων τα οποία
διαβάζουν μια τοπική μεταβλητή (local variable) μπορεί να αντιστραφεί καθώς το αποτέλεσμα αυτών των ενεργειών δεν επηρεάζεται από τη σειρά που αυτές θα γίνουν.
Υπάρχουν δύο τρόπου με του οποίους μπορούμε να κάνουμε partial order reduction. Ο πρώτος είναι το 
static partial order reduction \cite{Static1997} όπου η εξαρτήσεις μεταξύ των νημάτνω εντοπίζονται πρην την εκτέλεση του concurrent προγράμματος. 
Η δεύτερη προσέγγιση είναι το  Dynamic partial order reduction (DPOR) \cite{FlanaganDPOR} το οποίο παρατηρεί τις εξαρτήσεις του προγράμματος κατά την εκτλέση του.

Για μεγάλα προγράμματα ο DPOR διαρκεί περισσότερ από όσο θα ήταν επιθυμητό. Σε αυτές τις περιπτώσεις τεχνικές περιορισμού μπορεί να φανούν χρήσιμες. 
Οι τεχνικές περιορισμού σε αντίθεση με τον DPOR, αντιμετωπίζουν το πρόβλημα του state space explosion με το να μην ελέγχουν δρομολογήσεις που ξεπερνούν ένα όριο \cite{Thomson}.
Έχουν προταθεί πολλές τέτοιες τεχνικές όπως το preemption bounded exploration \cite{BPOR} ή το delay bounded exploration \cite{DelayBounded@POPL-11}. 
Όλες αυτές οι τεχνικές βασίζονται στην ιδέα ότι τα περισσότερα σφάλματαα μπορούν να εντοπιστούν ακόμα και με ένα μικρό όριο κάνοντας τον εντοπισμό των σφαλμάτων πολύ πιο γρήγορο.

Σε ότι αφορά αυτές τις τεχνικές, νέες προκλήσεις δημιουργούναι \cite{BPOR} καθώς εισάγονται περισσότερες εξαρτήσεις, που σχετίζονται με το όριο.
Πολλά περιττά traces πρέπει να εξερευνηθούν προκειμένου να σεβαστούμε το όριο δεδομένου ότι οι αλγόριθμοι δεν είναι σε θέση να γνωρίζουν αν ισοδύναμα traces  που αντιστοιχούν 
σε μεγαλύτερο bound έχουν ήδη ελεγχθεί.

Είναι σημαντικό να σημειωθεί ότι οι bounded techniques μπορούν να θεωρηθούν ως testing, με την έννοια ότι ελέγχουν μόνο ένα υποσύνολο του χώρου καταστάσεων αλλά και ως 
verification, με την έννοια ότ μπορούν επιβεβαιώσουν την απουσία σφαλμάτων για δεδομένο όριο.

\section{Διανυσματικά ρολόγια}

Ένα διανυσματικό ρολόι είναι ένας αλγόριθμος που προσδίδει μερική διάταξη σε κατανεμμημένα ή ταυτόχρονα συστήματα και εντοπίζει παραβιάσεις αιτιότητας (causality violations).
Ακριβώς όπως και στις χρονοσφραγίδες του Lamport (Lamport's timestamps) \cite{Lamport@CACM-89}, διαδιεργασιακά μηνύματα περιλαμβάμνουν πληροφορίες για την πρόοδο του λογικού ρολογιού
μιας διεργασίας.
Το διανυσματικό ρολό ενός συστήματος μεf $N$ διεργασίες έιναι ένα διάνυσμα από $N$ λογικά ρολόγια, ένα ρολόι ανά διεργασία.
Οι κανόνες με τους οποίους ενημερώνονται τα ρολογία δίνονται παρακάτω:

\begin{enumerate}
    \item Κάθε διεργασία που εκτελεί μια δική της εντολή αυξάνει το λογικό ρολόι της κατά ένα.
    \item Κάθε φορά που μια διεργασία λαμβάνει ένα μήνυμα ή εκτελεί μια ενέργεια σε μια μοιραζόμενη μεταβλήτη, αυξάνει το ρολόι της κατά ένα και ενημερώνει κάθε πεδίο του διανύσματς παίρνοντας το μέγιστο από τις τιμές από το δικό της διάνυσμα και τη μέγιστη τιμή από όλες τις διεργασίες που μοιράζονται αυτή τη μεταβλητή.
\end{enumerate}

Ένα παράδειγμα εκτέλεσης του αλγορίθμου δίνεται στο Figure \ref{Clock example} όπου δίνονται και ο πηγαίος κώδικας αλλά και το υπό εξερεύνηση ίχνος.
Μπορούμε εύκολα να διαπιστώσουμε ότι σε κάθε έντολή του thread <0> (main thread) το ρολόι του main thread αυξάνεται. Όταν το thread <0.0> ξεκινάει να εκτελείται το ρολόι του για το thread <0> είναι 8 καθώς εκείνη τη στιγμή δημιουργήθηκε από το main thread.
Όταν η τιμή του y διαβάζεται το ρολόι για το <0> αυξάνεται ξανά ώστε να αντιστοιχεί με το γεγονός y=1. Στη συνέχει το πρώτο νήμα δρομολογείται ξανά και το ρολόι του για το <0.0> είναι 7
καθώς η εντολή \verb|pthread_join()| εκτελείται.


\Side{./code/clocks.c}{Vector Clock example}{./code/clocks.out}{Vector Clock output}{Clock example}

Κάθε αλγόριθμος που παρουσιάζεται σε αυτή τη θέση βασίζεαται στα διανυσματικά ρολόγια. 


\section{Notation}

Πριν προχωρήσουμε βαθύτερα στο dynamic partial order reduction είναι πολύ σημαντικό να εξηγήσουμε τη σημειογραφία που θα χρησιμοποιήσουμε.
Μια ακολουθία εκτέλεσης $E$ ενός συστήματος που αποτελείται από περατό αριθμό βημάτων των διεργασιών του εκτελείται από την αρχική κατάσταση 
$s_0$. Δεδομένου ότι κάθε βήμα είναι ντερμινιστικό, μια ακολουθία εκτελέσεων $E$ χαρακτιρίζεται κατά μοναδικό τρόπο απο την ακολουθία των διεργασίων που εκτελούν εντολές στο $E$.
Για παράδειγμα, το $p.p.q$ συμβολίζει την εκτέλεση της ακολουθίας όπου το $p$ εκτελεί δύο βήματα, ακολουθούμενο από ένα βήμα του $q$.
Αυτή η ακολουθία από βήματα στο $E$ ορίζει μόναδικά και το global state του συστήματος μετά την εκτέλεση του $E$, που συμβολίζεται με $s_{[E]}$. 
Για ένα state $s$, το $enabled(s)$ συμβολίζει το σύνολο των διεργασιών $p$ 
που είναι ενεργές στο $s$ (για τις οποίες η εκτέλεση $p(s)$ ορίζεται). Χρησιμοποιούμε το $.$ για να συμβολίσουμε την ένωση (concatenation) ακολουθιών απο διεργασίες.
Έτσι, αν η $p$ δεν είναι μπλοκαρισμένη μετά το $E$, τότε $E.p$ είναι μια ακολουθία εκτελέσεων.
Ένα γεγονός στο $E$ είναι μια συγκεκριμένη εμφάνιση μια διεργασίες στο $E$.
Χρησιμοποιούμε το $\langle p,i \rangle$ για να συμβολίζουμε το i-οστό γεγονός μιάς διεργασίας $p$ στην εκτέλεση $E$. 
Με άλλα λόγια, το γεγονός $\langle p,i \rangle$ είναι το i-οστό βήμα τη διεργασίας $p$ στην εκτέλεση $E$. 
Με το $dom(E)$ συμβολίζουμε το σύνολο των γεγονότων $\langle p,i \rangle$ τα οποία ανήκουν στο $E$, i.e., $\langle p,i \rangle \in dom(E)$ ανν $E$
περιέχει τουλάχιστον $i$ βήματα του $p$. Θα χρήσιμποιούμε τα $e,e',...$ , για αναφερόμαστε σε διάφορα γεγονότα. 
Το $proc(e)$ συμβολίζει τη διερτασία $p$ ενός γεγονότος $e = \langle p, i \rangle$.
Αν $E.w$ είναι μια εκτέλεση, που προέκυψε από τη συνένωση του $E$ και του
$w$, τότε το $dom_{[E]}(w)$ θα είναι $dom(E.w) \ dom(E)$, δηλαδή τα γεγονότα στο
$E.w$ τα οποία ανήκουν στο $w$. Μια ειδική περίπτωση είναι η εξής: χρησιμοποιούμε το  $next_{[E]}(p)$ για να συμβολίσουμε το
$dom_{[E]}(p)$.
Το $<_E$ συμβολίζει τη συνολική διάταξη μεταξύ των γεγονότων του $E$, δηλαδή, το
$e <_E e'$ συμβολίζει ότι το  $e$ συμβαίνει πριν από το $e'$ στο $E$. Τέλος
χρησιμοποιούμε το $E'\leq E$ για να συμβολίσουμε ότι η ακολουθία $E'$ είναι
πρόθεμα της ακολουθίας $E$.

\section{Event Dependencies}

Μια από τις πιο σημαντικές έννοιες όταν χρησιμοποιούμε έναν αλγόριθμο που κάνει αναζήτηση σε όλο τον χώρο καταστάσεων των διαφόρων δρομολογήσεων είναι η σχέση
happens-before σε μια ακολουθία εκτέλεσης. Συνήθως αυτή η σχέση συμβολίζεται με $\rightarrow$. Για παράδειγμα η σχέση $\rightarrow$ 
για δύο γεγονότα $e,e'$ στο $dom(E)$ είναι αληθής τότε το γεγονός $e$ συμβαίνει πριν το $e'$. Αυτή η σχέση συνήθως εμφανίζεται στην ανατλλαγή μηνυμάτνων όταν το  $e$ 
είναι η μετάδοση μηνύματος και το $e'$ είναι το γεγονός της λήψης του μηνύματος. Για παράδειγμα στο Nidhugg το $e \rightarrow e'$ δε θα ήταν αληθές αν τουλάχιστον ένα από τα δύο γεγονότα
δεν ήταν write operation στην ίδια μοιραζόμενη μεταβλητή. Είναι λογικό κάθε DPOR αλγόριθμος να μπορεί να προσδώσει τέτοιες happens-before σχέσεις. 
Πρακτικά η happens-before ανάθεση υλοποιείται με τη χρήση vector clocks.

\begin{definition}{(happens-before ανάθεση)}
    Μια happens-before ανάθεση, η οποία αναθέτει μια μοναδική σχέση
    happens-before $\rightarrow E$ σε κάθε ακολουθία εκτέλεσης
    $E$, είναι έγκυρη αν ικανοποιεί τις ακόλουθες ιδιότητες για κάθε $E$.
    \begin{enumerate}
        \item Το $\rightarrow_{E}$ είναι μια μερική διάταξη στο $dom(E)$, που περιλαμβάνεται στο $<_E$. Με άλλα λόγια κάθε δρομολόγηση είναι μέρος μια μερικής διάταξης που μπορεί να παράξει το πρόγραμμα.
        \item Τα βήματα εκτέλεση κάθε διεργασίας είναι πλήρως διατεταγμένα, δηλαδή
        $\langle p,i \rangle \rightarrow_E \langle p,i+1 \rangle$ όποτε ισχύει $\langle p, i+1 \rangle \in dom(E)$.
        \item Αν $E'$ είναι πρόθεμα του $E$ τότε $\rightarrow_E$ και $\rightarrow_{E'}$ είναι ίδια στο $dom(E')$.
        \item Κάθε γραμμικοποίηση (linearization) $E'$ of $\rightarrow_E$ στο $dom(E)$ είναι μια ακολουθία εκτέλεσης ακριβώς ίδια με τη “happens-before” σχέση.
$\rightarrow_{E'}$ as $\rightarrow_E$. Αυτό σημαίνει ότι η σχέση $\rightarrow_E$ επάγει ένα σύνολο
από ισοδύναμες ακολουθίες εκτέλεσης, όλες με την ίδια “happens-before” σχέση. 
Το $E \simeq E'$ συμβολίζει ότι τα $E$ και $E'$ είναιe
γραμμικοποιήσεις της ίδιας “happens-before” σχέσης, και το $[E] \simeq$ 
συμβολίζει την ισοδυναμία στην περίπτωση του E.
    \item Αν $E \simeq E'$ τότε $s_{[E]} = s_{[E']}$ (δύο ισοδύναμα traces θα οδηγήσουν στο ίδιο state).
    \item Για μια ακολουθία $E, E'$ και $w$, ώστε η $E.w$  είναι μια ακολουθία εκτέλεσης, έχουμε ότι $E \simeq E'$  ανν $E.w \simeq' E'.w$.
    \end{enumerate}
\end{definition}

\section{Ανεξαρτηστία και Ανταγωνισμός}

Μπορούμε πλέον να ορίσουμε την ανεξαρτησία μεταξύ υπολογισμών. Αν
$E.p$ και $E.w$ είναι δύο ακολουθίες εκτέλεσης, τότε το $E \models p\diamondsuit w$ συμβολίζει
ότι το $E.p.w$ είναι μια ακολουθία εκτέλεσης τέτοια ώστε $next_{[E]}(p) \not \rightarrow_{E.p.w} e$
για κάθε $e \in dom([E.p])(w)$. Με άλλα λόγια, το $E \models p \diamondsuit w$ δηλώνει ότι
το επόμενο γεγονό του $p$ δε θα “συμβεί πριν” από κάποιο άλλο στο $w$
στην ακολουθία εκτέλεσης $E.p.w$. Διαισθητικά, αυτό σημαίνει ότι το $p$ είναι
ανεξάρτητο από το $w$ μετά το $E$. Στην ειδική περίπτωση όπου το  $w$ περιέχει
μόνο μια διεργασία $q$, τότε το $E \models p \diamondsuit q$ συμβολίζει ότι τα επόμεντα βήματα των 
$p$ και $q$ είναι ανεξάρτητα μετά το $E$. Το $E'\models p \diamondsuit w$ συμβολίζει ότι το 
$E \not \models p \diamondsuit w$ δεν ισχύει.

Για μια ακολουθία $w$ με $p \in w$, let $w \backslash p$ συμβολίζουμε την ακολουθία
$w$ με την πρώτη εμφάνσιση του $p$ να έχει αφαιρεθεί, και το $w \uparrow p$ συμβολίζει
το πρόθεμα του $w$ μέρχι αλλά χωρίς να συμπεριλαμβάνει την πρώτη εμφάνιση του $p$. Για
μια ακολουθία εκτέλεσης $E$ και ένα γεγονός $e \in  dom(E)$, έστω ότι το $pre(E,e)$
συμβολίζει το πρόθεμα του $E$ μέχρι αλλά χωρίς να συμπεριλαμβάνει το $e$. Για μια
ακολουθία εκτέλεσης $E$ και ένα γεγονός $e \in E$, το $notdep(e, E)$ είναι η
υπακολουθία του $E$ που αποτελείται από τα γεγονότα που συμβαίνουν μετά το $e$ αλλά δε 
“συμβαίνουν μετά” το $e$ (δηλαδή τα γεγονότα  $e'$ που συμβαίνουν μετά το $e$ για τα οποία ισχύει
$e \not \rightarrow_E e'$).


Μια κεντρική έννοια στους περισσότερους DPOR αλγορίθμου είναι αυτή του ανταγωνισμού.
Διαισθητικά, δύο γεγονότα $e$ και $e'$ σε μια ακολουθία εκτέλεσης $E$, όπου το
$e$ συμβαίνει πριν το $e'$ στο $E$, συναγωνίζοναι αν
\begin{itemize}
\item Το $e$ συμβαίνει πριν το $e'$ στο  $E$, και
\item τα $e$ και $e'$ είναι ταυτόχρονα, δηλαδή υπάρχει μια ισοδύναμη ακολουθία εκτέλεσης 
$E' \simeq E$ στην οποία τα $e$ και $e'$ είναι γειτονικά.
\end{itemize}
Τυπικά, έστω ότι τα $e \lessdot_E e'$ συμβολίζουν ότι  $proc(e) \not = proc(e')$, ότι $e \rightarrow_E e'$,
και ότι δεν υπάρχει γεγονός  $e'' \in dom(E)$, διαφορετικό από τα $e'$ και $e$,
τέτοιο ώστε $e \rightarrow_E e'' \rightarrow_E e'$.

Όποτεδήποτε ο DPOR εντοπίζει συναγωνισμό, ελέγχει αν τα γεγονότα που συναγωνίζονται μπορούν να εκτελεστούν σε αντίστροφη σειρά.
Δεδομένου ότι τα γεγονότα συνδέονται με σχέσεις happens-before, μπορεί να οδηγηθούμε σε διαφορετικά
global state: έτσι ο αλγόριθμος πρέπει να προσπαθήσει να εξερευνήσει την αντίστοιχη ακολουθία εκτέλεσης
Έστω ότι το $e \lesssim_E e'$ συμβολίζει ότι
$e \lessdot_E e'$, και ότι ο συναγωνισμός μπορεί να αντιστραφεί. Τυπικά, αν $E' \lesssim E$
και το $e$ συμβαίναι ακριβώς πριν το $e'$ στο $E'$, τότε η $proc(e')$ δεν ήταν μπλοκαρισμένη
πριν την εμφάνιση του $e$.


\section{Dynamic Partial Order Reduction}

Πριν εξηγήσουμε τον DPOR αλγόριθμο είναι σημαντικό να όρισουμε τα επαρκή σύνολα (sufficient sets).

\begin{definition}{(Επαρκές Σύνολο)}
Ένα σύνολο από μεταβάσεις είναι επαρκές σύνολο στην κατάσταση $s$ αν κάθε σχετική κατάσταση που είναι προσβάσιμη μέσω μιας δυνατής μεταβάσης από το
$s$ είναι προσβάσιμη και από το $s$ μέσω τουλάχιστον μίας μετάβασης στο επαρκές σύνολο.
Μια αναζήτηση χρειάαζεται να εξερευνήσεις μόνο μεταβάσεις που ανήκουν στο επαρκές σύνολο από το 
$s$ επείδή όλα τα σχετικά states θα εξακολουθήσουν να είναιn
προσβάσιμα. Το σύνολο που περιέχει όλα τα ενεργά threads είναι τετριμένα επαρκές στο 
$s$, αλλά μικρότερα επαρκή σύνολα επιτρέπουν μεγαλύτερο περιορισμό του χώρου καταστάσεων.
\end{definition}

Πολλές τεχνικές έχουν προταθεί για την υλοποίηση ενός DPOR αλγορίθμου. Αυτό που έχουν όλες οι τεχνικές κοινό είναι η παρακάτω μορφή.

\ref{GeneralDPOR}.
\SetKwProg{Fn}{Function}{}{}

\SetKwHangingKw{Let}{let}
\begin{algorithm}[H]
    \caption{General form of DPOR}
    \label{GeneralDPOR}
    Explore($\emptyset$)\;
    \Fn{Explore($E$)}{
     \Let{$T = Sufficient\_set(final(E)$)}
     \For{all $t \in T$}{
        Explore($E.t$) \;
    }
    }
\end{algorithm}

όπου το $final(E)$ αντιπροσωπεύει την κατάσταση που θα φτάσουμε ότι η ακολουθία $E$ εκτελεστεί.

Ο αλγόριμος περιγράφει μια DFS αναζήτηση στο χώρο καταστάσεων όλων των πιθανών interleavings.
Όπως μπορούμε να υποθέσουμε το πιο σημαντικό κομμάτι του αλγορίθμου είναι ο υπολογισμός του συνόλου $T$.

Μια προφανής ιδιότητα που πρέπει να ισχύει είναι ότι Sufficient\_set$(final(E)) \subseteq enabled(E)$.

Διαισθητικά τα $enabled(s)$ αντιπροσωπεύουνν τα νήματα εκείνα που δεν είναι μπλοκαρισμένα και η εκτέλεση τους δεν έχει ολοκληρωθεί.

Στη βιβλιογραφία πολλά είδη επαρκών συνόλων μπορούν να βρεθούν \cite{Godefroid1996}. 
Σε αυτή τη διπλωματική εστιάζουμε στα επίμονα σύνολα (persistent sets) και στα πηγαία σύνολα (source sets).


\section{Επίμονα Σύνολα}

\begin{definition}{(Επίμονα Σύνολα - Persistent Sets)}
Έστω $s$ ένα state, και έτσω $W \subseteq E(s)$ ένα σύνολο από ακολουθίες εκτέλεσης από το 
$s$. Ένα σύνολο $T$ μεταβάσεων είναι επίμονο σύνολο για το $W$
μετά το $s$ αν για κάθε πρόθεμα του $w$ από κάποιες ακολουθίες στο $W$, οι οποίες δεν πειρέχουν εμφανίσεις από μεταβάσεις στο 
$T$,  έχουμε ότι $E \vdash t \diamondsuit w$ για κάθε $t \in T$.
\end{definition}

Ο παραπάνω ορισμό μπορεί να περιγραφέι και ώς εξής: Αν $t \in T$ και δεν υπάρχει άλλο thread $t'$ το οποίο μπορεί να εκτελεσθεί μέχρι μια εντολή η οποία βρίσκεται σε συναγωνισμό
με το $t$, τότε το $t'$ ανήκει στο επίμονο σύνολο.

Πρέπει να σημειώσουμε ότι αυτός ορισμός προτείναι και ένα τρόπο κατασκευής του.

Στο Figure \ref{Construction of persistent sets} παρουσιάζονται δύο διαφορετικά παραδείγματα κατασκευής επίμονων συνόλων. Συμβολίζουμε το επίμονο σύνολο από διακλαδώσεις που μπορεί 
να πάρει η εκτέλεση με $BR{}$.
Στο πϱώτο παράδειγμα, έστω ένα concurrent program που περιέχει 3 threads $p$, $q$, και $r$. Το thread $p$ μεταβάλλει την τιμή της μεταβλητής(writer) και τα άλλα ($q$ και $r$) απλά διαβάζουν την τιμή αυτών των μεταβλητών (readers).
Έστω $p.q.q.r.r$ ένα interleaving. Σύμφωνα με τον ορισμό των επίμονων συνόλων, τα $q$ και $r$ συναγωνίζονται με το $p$, επομένως, τα $q$ και $r$ πρέπει να ανήκουν και αυτά
στο επίμονο σύνολο.
Στο Figure \ref{Construction of persistent sets} παρατηρούμε ότι και το $r$ και το $q$ thread προστίθενται στο επίμονο σύνολο της πρώτης εντολής καθώς και τα δύο έχουν conflict 
με το write operation.
Στο δεύτερο παράδειγμα, έστω τα $p$ και $r$ είναι αναγνώστες και $q$ είναι εγγραφέας. Παρατηρούμε ότι και το $r$ και το $q$ προστίθενται. Παρολ᾽ αυτά δεν υπάρχει conflict μεταξύ των 
$p$ και $r$ καθώς και τα δύο είναι αναγνώστες της μεταβλητής 
$x$. Ο λόγος είναι ότι το thread $r$ έχει conflict που προκύπτει από την έγγραφή που θα εκτελέσει το $q$.

\trace{persistent.pdf}{Construction of persistent sets}

\section{Πηγαία Σύνολα - Source Sets}

Πριν δώσουμε των ορισμό των πηγαίων συνόλων (source sets), πρέπει να δώσουμε κάποιους άλλους χρήσιμους ορισμούς.

\begin{definition}{($dom(E)$)}
    Το σύνολο των μεταβάσεων που συμβαίνει σε μια δρομολόγηση του $E$.
\end{definition}

\begin{definition}{(Initials μιας ακολουθίας εκτέλεσης $E.w$, $I_{[E]}(w)$)}
Για μια ακολουθία εκτέλεσής $E.w$, έστω ότι το $I_{[E]}(w)$ συμβολίζει το σύνολων των διεργασιών που προκαλούν ένα γεγονός 
$e$ στο $dom_{[E]}(w)$ τα οποία δεν έχουν
“happens-before” πρόγονο στο $dom_{[E]}(w)$. Πιο τυπικά,
$p \in I_{[E]}(w)$ αν $p \in w$ και δεν υπάρχει άλλο γεγονός $e \in dom_{[E]}(w)$ για το οποίο ισχύει
$e \rightarrow_{E.w} next_{[E]}(p)$.
\end{definition}

Χαλαρώνοντας τον ορισμό για τα Initials παίρνουμε τον ορισμό των Weak Initials, $WI$.

\begin{definition}{(Weak Initials μετά από μια ακολουθία εκτέλεσης $E.w$, $WI_{[E]}(w)$)}
Για μια ακολουθία εκτέλεσης $E.w$, έστω ότι $WI_{[E]}(w)$ είναι η ένωση των $I_{[E]}(w)$ με το σύνολο των διεργασιών που μπορούν να εκτελέσουν μια εντολή δηλαδή
αν $p \in enabled(s_{[E]}) $.
\end{definition}

Το νόημα αυτών των δύο εννοιών για μια ακολουία $E.w$ είναι το εξής:
\begin{itemize}
    \item  $p \in I_{[E]}(w)$ ανν υπάρχει μια ακολουθία $w'$ τέτοια ώστε $E.w \simeq E.p.w'$, και
    \item  $p \in WI_{[E]}(w)$ ανν υπάρχει μια ακολουθία $w'$ και $v$ τέτοια ώστε $E.w.v \simeq E.p.w'$.
\end{itemize}

\begin{definition}{(Πηγαία Σύνολα - Source Sets)}
Έστω $E$ μια ακολουθία εκτέλεσης,
και έστω $W$ ένα σύνολο από ακολουθίες, τέτοιο ώστε $E.w$ είναι μια ακολουθία
για κάθε $w \in W$. Το σύνολο $T$ των διεργασιών είναι πηγαίο σύνολο του 
$W$ μετά το $E$ αν για κάθε $w \in W$ έχουμε ότι $WI_{[E]}(w) \cap P  = \emptyset$.
\end{definition}

Το πηγαίο σύνολο είναι ένα σύνολο από threads το οποίο μας εγγυάται ότι όλος ο χώρος καταστάσεων θα εξερευνηθεί.
Είναι σημαντικό να παρατηρήσουμε ότι τα πηγαία σύνολα δε συνδέονται με συναγωνισμό μεταξύ γεγονότων
Αυτό που υπονοεί ο ορισμός είναι ότι πηγαίο σύνολο πρέπει να θεωρείαι κάθε σύνολο από νήματα που περιέχει αυτά τα threads
που μπορούν να καλύψουν όλο το χώρο καταστάσεων
Στην πραγματικότητα ο ορισμός δίνει μια ιδιότητα για τα επαρκή σύνολα.

\section{Κοιμώμενα Σύνολα - Sleep Sets}

Μια ακόμα τεχνική συμπληρωματική με τα επίμονα και τα πηγαία σύνολα που στοχεύει να μειώσει την εξερεύνηση περιττών interleavings είναι η τεχνική των κοιμώμενων συνόλων (Sleep Sets)
Τα sleep sets εμποδίζουν μια είδη χρησιμοποιημένη μετάβαση να ξαναχρησιμοποιηθεί μέχρι η εξερεύνηση να φτάσει σε μια μετάβαση που έχει εξάρτηση από τη μετάβαση που βρίσκεται
ήδη στο sleep set.
Ας υποθέσουμε ότι η εξερεύνηση χρησιμοποιεί μια μετάβαση 
$t$ από ένα state $s$, προσθέτει στο backtrack $t$,
και στη συνέχεια εξευρευνά το  $t_0$ από $s$. Μέχρι η αναζήτηση συναντήσει μια μετάβαση που είναι που είναι σε συναγωνισμό με το 
$t$, κανένα state δεν είναι προσβάσιμο μέσω του
$t_0$ που δεν θα ήταν ήδη προσβάσιμες μέσω του $t$ από το s. Επομένως, το $t$
“κοιμάται” μέχρι μια μετάβαση με συναγωνισμό εξερευνηθεί.

Ένα μικρό παράδειγμα είναι αυτό που ακολουθεί:
Έστω ένα concurrent πρόγραμμα που αποτελείται από έναν εγγραφέα (w1) και δύο αναγνώστες (r1,r2).
Έστω w1 <0.0>: w(x) r1 <0.1>: (local operations), r(x) και r2 <0.2>: (local operations), r(x).

Το trace που παίρνουμε σαν αποτέλεσμα φαίνεται στο Listing \ref{Sleep set example}. Ας σημειωθεί ότι όποτε μια διεργασία εκτελεί μια εντολή
η οποία βρίσκεται σε συναγωνισμό με μια εντολή απο άλλη διεργασία η οποία ``κοιμάται'', ξυπνάει. 
Όπως μπορούμε να συμπεράνουμε από την εκτέλεση του DPOR το interleaving που ξεκίνησε από το r2 μπλόκαρε καθώς θα οδηγούσε σε ένα interleaving το οποίο έχουμε ήδη εξερευνήσει.
Ας σημειώσουμε ότι λόγω του ότι το r1 δεν ``ξυπνάει'' καθώς η πρώτη μετάβαση (local operations) δεν έχει conflict με κάποια άλλη μετάβαση.

Αποδεικνύεται \cite{Godefroid1996} ότι τα sleep sets μπορούν να μπλοκάρουν κάθε περιττή μετάβαση και επομένως μονο κατάλληλα interleavings θα εξερευνηθούν μέχρι το τέλος.


\Output{./code/sleep_sets.out}{Sleep set example}

\section{Σύγκριση Persistent Sets με Source Sets}

Ας σημειωθεί ότι ο ορισμός των source sets είναι πολύ πιο χαλαρός από τον αντίστοιχ των persistent sets. 
Αυτή η χαλάρωση επιτρέπει στα source sets να είναι πολύ πιο αποδοτικά από τα persistent sets. Στο Figure \ref{Non-minimal persistent sets}
ένα παράδειγμαα δίνεται που δείχνει τη διαφορά των δύο.

\begin{figure*}
    \begin{lstlisting}[frame=none,numbers=none]
        Initially: x = y = z = 0 
    \end{lstlisting}
    \begin{minipage}{0.3\textwidth}
      \begin{lstlisting}[frame=none, numbers=none]
        p:
        m := x; (p1)
        if (m = 0) then
            z := 1; (p2)
      \end{lstlisting}
    \end{minipage}
    \begin{minipage}{0.3\textwidth}
        \begin{lstlisting}[frame=none, numbers=none]
            q:
            n := y; (q1)
            if (n = 0) then
                x := 1; (q2)
        \end{lstlisting}
      \end{minipage}
      \begin{minipage}{0.3\textwidth}
        \begin{lstlisting}[frame=none, numbers=none]
            r:
            o := z; (r1)
            if (o = 0) then
                y := 1; (r2)
        \end{lstlisting}
      \end{minipage}
      \caption{Program with non-minimal persistent sets}
      \label{Non-minimal persistent sets}
  \end{figure*}

Από το παράδειγμα, είναι σαφές ότι ο λόγος που τα source sets είναι καλύτερα από τα persistent sets είναι το γεγονό ότι τα minimum source μπορούν να εξαλείψουν τελείως
sleep set blocked traces δηλαδή traces που θα μπλοκάρονταν από τα sleep sets. Ένας αλγόριθμος που θα μπορούσε να υπολογίσει minimal source sets θα ήταν βέλτιστος \cite{AbdullaAronisJohnssonSagonasDPOR2014}, και επομένως δε θα εξερευνούσε ποτέ περιττά interleavings.

Είναι προφανές ότι μια μόνο μετάβαση δεν μπορει να είναι source set. Για παράδειγμα,
το σύνολο $\{ p_1 \}$ δεν περιέχει initials της εκτέλεσης $q_1.q_2.p_1.r_1.r_2$,
καθώς τα q2 και p1 εκτελούν conflicting accesses. Από την άλλη μεριά, κάθε υποσύνολο
που περιέχει δύο enabled μεταβάσεις είναι source set. Για να το δούμε αυτό ας διαλέξουμε το
$\{p_1, q_1 \}$ ως source set. Προφανώς, το $\{p1, q1 \}$ περιέχει ένα initial για κάθε εκτέλεση
που ξεκινά είτε με το $p_1$ ή το $q_1$. Κάθε εκτέλεση που ξεκινά με το $r_1$ είναι 
ισοδύναμη με την εκτέλεση που παίρνουμε αν θέσουμε ώς πρώτο βήμα είτε το $p_1$ ή το $q_1$:

\begin{itemize}
\item Αν το $q_1$ συμβεί πριν το $r_2$, τότε το $q_1$ είναι initial, καθώς δεν έχει conflict
με κάποια άλλη μετάβαση.
\item Αν το $q_1$ συμβαίνει πριν το $r_2$, τότε το $p_1$ είναι ανεξάρτητο από όλα τα βήματα και $p_1$ είναι initial.
Ισχυριζόμαστε ότι το $\{p_1, q_1 \}$ δεν μπορεί να είναι persistent set. Ο λόγος είναι ότι η εκτέλεση $\{r_1.r_2 \}$ δεν περιέχει καμία μετάβαση που να είναι
στο persistent set, αλλά το βήμα είναι εξαρτόμενο από το $q_1$. 
\end{itemize}

Με άλλα λόγια, τα persistent sets έχουν τη δυσάρεστη ιδιότητα όταν προσθέτουμε μία διεργασία στο
persistent set να προστίθενται επιπλέον διεργασίες.

Συνεχίζοντας τη σύγκρισή μεταξύ source sets και persistent sets, 
πρέπει να σημειώσουμε δύο ιδιότητες.

\begin{itemize}
\item Κάθε persistent set είναι source set.
\item Κάθε one-process source είναι persistent set.
\end{itemize}


\section{Bounded Search και Preemption Bounding}

Η περιορισμένη αναζήτηση - bounded search εξερευνά μόνο εκτελέσεις που δεν ξεπερνούν κάποιο όριο \cite{BPOR,Thomson}. 
Το όριο μπορεί να είναι μια ιδιότητα της ακολουθίας.
Μια συνάρτηση υπολογισμού του ορίου $B_v(E)$
δίνει μια τιμή σε μια ακολουθία $E$.
Η συνάρτηση υπολογισμού $B_v$ και το όριο $c$ είναι είσοδη στην περιορισμένη αναζήτηση.
Προφανώς το bounded search μπορεί να μην έχει πρόσβαση σε όλα τα προσβάσιμα states της unbounded αναζήτησης.
Αντίθετα επισκέπτεται μόνο states που είναι προσβάσιμα μέσα στο bound.

Ένας αλγόριθμος που περιγράφει το bounded search θα ήταν ο ακόλουθος:

\begin{algorithm}[H]
    \caption{Bounded-DPOR}
    \KwResult{Explore the whole statespace}
    Explore($\emptyset$)\;
    \Fn{Explore($E$)}{
        T = Sufficient\_set($final(E)$)
     \For{all $t \in T$}{
         \If{$B_v(E.t) \leq c$}{
            Explore($E.t$)
         }
        }
    }
\end{algorithm}

\noindent Η μόνη διαφορά μεταξύ unbounded και bounded εκδοχής είναι το if-statement στη γραμμή 4 που επιτρέπει την εξερεύνηση interleaving μόνο αν το bound δεν έχει 
ξεπεραστεί.

Το μόνο που μένει είναι ο ορισμός μια κατάλληλης $B_v$ που υπολογίζει την τιμή που ο bounded-DPOR προσπαθεί να κρατήσει κάτω από ένα όριο καθώς και το 
sufficient set.

Σε αυτή τη διπλωματική μας απασχολεί το preemption-bounded search.

Το preemption-bounded search περιορίζει τον αριθμό των preemptive context switches που συμβαίνουν σε μια εκτέλεση \cite{Musu07}. Το
preemption bound δίνεται ανααδρομικά από τον ακόλουθο τύπο. 

\begin{definition}{(Preemption bound)}
\\
$P_b(\emptyset) = 0$ \\
$P_b(E.t) = 
 \begin{cases} 
    P_b(E) + 1 & \text{ if } t.tid = last(E).tid \text{ and } last(E).tid \in enabled(final(E)) \\
    P_b(E) & \text{ otherwise }
 \end{cases}
$\\
\end{definition}

Ο ορισμός περιγράφει τί είναι ένα preemptive context switch. Preemptive context switch έχουμε όταν ένα thread που έτρεχε σταματήσει για να εκτελεστεί ένα άλλο

\section{Preemption Bounded Persistent Sets}

Ένα σύνολο που έχει προταθεί ως sufficient για preemption bounded search είναι το preemption bounded persistent set \cite{BPOR}.

Μια σημαντική παρατήρηση που πρέπει να κάνουμε είναι ότι ένα thread που μπλοκάρει είν τερματίζει δε θα αυξήσει το  count.

\begin{definition}{($ext(s,t)$)}
    Given a state $s = final(E)$ and a transition $t \in enabled(s)$,
    $ext(s,t)$ returns the unique sequence of transitions $\beta$ from $s$
    such that
    \begin{enumerate}
        \item $\forall i \in dom(\beta): \beta_i.tid = t.tid$
        \item $t.tid \notin enabled(final(E.\beta))$
    \end{enumerate}
\end{definition}

Στη συνέχει ορίζουμε τα preemption bounded persistent sets. Συμβολίζουμε με $A_G(P_b,c)$ Το generic 
bounded state space την  bound function με $P_b$ και το bound με $c$. Το $last(a)$ συμβολίζει το τελευταίο βήμα εκτέλεσης της ακολουθίας $a$.

\begin{definition}{(Preemption bounded persistent set)}

Ένα σύνολο $T \subseteq \mathcal{T}$ από δυνατές μεταβάσεις στο state $s=final(e)$
είναι preemption-bound persistent στο $s$ ανν για κάθε μη κενή ακολουθία
$a$ απο μεταβάσεις από $s$ στο $A_G(P_b,c)$ τέτοιο ώστε 
$\forall i \in dom(a), a_i \notin T$ για κάθε $t \in T$ ,

\begin{enumerate}
\item $Pb(E.t) \leq Pb(E.a_1)$
\item if $Pb(E.t)<Pb(E.a_{1}) ,$ then $t \leftrightarrow last(a)$ and $t \leftrightarrow  next(final(E.a), last(a).tid)$
\item if $Pb(E.t)=Pb(E.a_{1}),$ then $ext(s,t) \leftrightarrow last(a)$ and $ext(s,t) \leftrightarrow next(final(E.a), last(a).tid)$
\end{enumerate}

\end{definition}

Όταν έχουμε να κάνουμε με preemption bounded DPOR είναι χρήσιμο να εισάγουμε την έννοια του block μιας ακολουθίας.

\begin{definition}{(Block μια ακολουθίας εκτέλεσης)}
    Block μιας ακολουθίας εκτέλεσης είναι κάθε κομματι της ακολουθίας που αποτελείται από εκτελέσεις του ίδου thread.
\end{definition}

Στο Figure \ref{Example of blocks} υπάρχουν τρία blocks. Το πρώτο block είναι το κίτρινο, το δεύτερο το πράσινο και το τρίτο το μπλέ.

\trace{blocks.pdf}{Example of blocks}

Έστω $P$ ένα persistent set. Preemption bounded persistent set είναι ένα σύνολο που περιέχει όλα τα $p \in P$ με την προσθήκε όλων των
threads που θα προστιθεντο στο block που θα δημιουργούνταν όταν το $p$ δρομολογούνταν. Αυτές οι διακλαδώσεις ονομάζοντια συντηρητικές (conservative) και ο στόχος τους είναι 
να επιτρέψουν την ανακάλυψη interleaving που δεν ξεπερνούν το bound. Σημειώστε ότι μια διακλάδωση μπορεί να είναι και conservative και non-conservative.
Τα preemption bounded persistent sets επεκτείνουν τα persistent set βαζοντας όλα τα threads που θα δημιουργήσουν καινουρια block στη συνέχεια.

